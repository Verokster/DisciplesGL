/*
	MIT License

	Copyright (c) 2020 Oleksiy Ryabchun

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in all
	copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE.
*/

#include "StdAfx.h"
#include "Shellapi.h"
#include "Objbase.h"
#include "Mmsystem.h"
#include "Commdlg.h"
#include "process.h"
#include "intrin.h"
#include "Hooks.h"
#include "Main.h"
#include "Config.h"
#include "Resource.h"
#include "Window.h"
#include "PngLib.h"
#include "Mods.h"
#include "Hooker.h"

#define PANEL_WIDTH 160
#define NUM(a, b) ((a << 16) | b)
#define VER(a, b, c, d) NUM(a, b), NUM(c, d)

namespace Hooks
{
	const BYTE nop4[] = { 0x83, 0xC4, 0x04, 0x90, 0x90 };

	const AddressSpaceV1 addressArrayV1[] = {
		// v99.8.17.1
		VER(99, 8, 17, 1),
		0x004C25E4, 0x004D2D75, 0x00000000, 0x004D34C1, 0x004D33A7, 0x005829B5,
		0x005CB220, 0x005D61A8, 0x004D4FA0, 0x0052B2B9, 0x00461263, 0x004E3621, 0x004E3E06, 0x004E40AA,
		0x004D9FE3, 0x004DA04E, 0x004BF1F1, 0x004BF8EC, 0x004D49DD, 0x00000000,

		// v99.8.20.2
		VER(99, 8, 20, 2),
		0x004C3BD5, 0x004D439E, 0x00000000, 0x004D4AEA, 0x004D49D0, 0x00583F85,
		0x005CD348, 0x005CDA58, 0x004D6597, 0x00545A91, 0x004623A7, 0x004E4E36, 0x004E55B6, 0x004E585A,
		0x004DB63A, 0x004DB6A5, 0x004C063C, 0x004C0D37, 0x004D5FD4, 0x004012DA,

		// v99.12.15.1a
		VER(99, 12, 15, 1),
		0x004CD137, 0x004DFFA4, 0x00000000, 0x004E06D3, 0x004E05B9, 0x0058F7E3,
		0x005E6320, 0x005DB2A0, 0x004E21B5, 0x00550B69, 0x00465296, 0x004F07F5, 0x004F1006, 0x004F12AA,
		0x004E7094, 0x004E70FF, 0x004C9AFD, 0x004CA224, 0x004E1BF7, 0x0040120E,

		// v99.12.15.1b
		VER(99, 12, 15, 1),
		0x004CD1B2, 0x004E002A, 0x00000000, 0x004E0759, 0x004E063F, 0x0058F053,
		0x005DB2B0, 0x005E6330, 0x004E21D6, 0x005507D6, 0x004652BF, 0x004F0A1C, 0x004F11B6, 0x004F145A,
		0x004E7316, 0x004E7381, 0x004C9AAE, 0x004CA1D5, 0x004E1C13, 0x0040120E,

		// v2000.6.22.1 - Eng Steam
		VER(2000, 6, 22, 1),
		0x004CD13E, 0x004DFF9C, 0x00000000, 0x004E0759, 0x004E063F, 0x0058F0D3,
		0x005E6358, 0x005DB2D8, 0x004E225C, 0x0055037A, 0x0046523E, 0x004F07B0, 0x004F0FB6, 0x004F125A,
		0x004E712F, 0x004E719A, 0x004C9B9A, 0x004CA2B4, 0x004E1C9E, 0x00000000,

		// v2000.6.22.1 - Rus
		VER(2000, 6, 22, 1),
		0x004CD408, 0x004E0323, 0x00000000, 0x004E0AA8, 0x004E098E, 0x00590E03,
		0x005E8430, 0x005DD278, 0x004E2565, 0x0055106A, 0x0046541D, 0x004F0B39, 0x004F12D6, 0x004F157A,
		0x004E746D, 0x004E74D8, 0x004C9D9F, 0x004CA4C6, 0x004E1FA7, 0x0040120E,

		// v99.8.17.2 Editor
		VER(99, 8, 17, 2),
		0x004444C2, 0x0044F4FD, 0x00426AE5, 0x0044FC2C, 0x0044FB12, 0x00000000,
		0x0050C170, 0x00000000, 0x004517FC, 0x0049E957, 0x00000000, 0x004601D3, 0x00460966, 0x00460C0A,
		0x00456896, 0x00456901, 0x004411CB, 0x004418D2, 0x0045123E, 0x00000000,

		// v99.12.15.1 Editor
		VER(99, 12, 15, 1),
		0x00443D2A, 0x004511FC, 0x00426437, 0x004519CE, 0x004518B4, 0x00000000,
		0x00518530, 0x00000000, 0x0045358A, 0x0049FA73, 0x00000000, 0x0046204D, 0x00462796, 0x00462A3A,
		0x0045871D, 0x00458788, 0x00440AC2, 0x004411C9, 0x00452FC7, 0x00000000,

		// v2000.6.22.1 Editor
		VER(2000, 6, 22, 1),
		0x00443EDE, 0x0045147D, 0x004265E3, 0x00451BE8, 0x00451ACE, 0x00000000,
		0x00519568, 0x00000000, 0x004537B8, 0x004A041A, 0x00000000, 0x0046229D, 0x00462AF6, 0x00462D9A,
		0x00458961, 0x004589CC, 0x00440BC6, 0x004412CD, 0x004531FA, 0x00000000
	};

	const AddressSpaceV2 addressArrayV2[] = {
#pragma region v2_00
		// v2.00
		NUM(2, 00), VER(2003, 4, 7, 1),
		0x00564A6B, 0x005C9B23, 0x0066FF71, // random_nop

		0x005BB6FB, 0x005A7814, 0x005BC3BB, 0x00675870, 0x006759D7, 0x005A770C, // memory_6
		0x006EA4D8, 0x0055E93F, 0x00676D46, 0x0055EAD5, 0x006E397C, 0x005B6D10, // mapGround
		0x005B6C10, 0x0052957B, 0x005AE403, 0x006E34B8, 0x005319EE, 0x00531A87, // verLine
		0x0053975F, 0x0053979E, 0x005397A7, 0x005397F9, // unknown_2

		0x006134D0, 0x00613534, 0x004024F9, 0x0053A3FB, // border_hook
		0x00515E12, 0x0051A380, 0x00515502, 0x005C85E8, 0x005C85A9, 0x00489498, 0x0048624A, // minimap_fill 0x00000000, 0x00000000, 0x00000000, // maxSize_3
		0x0051621F, 0x0051632E, 0x006693B4,

		0x00546C70, 0x00547C9E, 0x00547AF9, 0x00547744, 0x00546E5B, 0x005476F7, // png_read_image
		0x005486B9, 0x00549E1C, 0x00548B21, 0x005482F5, 0x00548843, 0x00548581, 0x00548CF2, 0x005493FC, // png_set_IHDR

		0x0053E556, 0x0053ECB3, 0x00000000, 0x00000000, 0x0053ED55, 0x0053EBF8, 0x0053BB2D, // dblclick_hook

		0x00625CE5, 0x0063FD28, 0x00626DD3, 0x0062667F, 0x0062A06A, 0x00630C74, 0x0062696D, 0x00630D08, // btlGroupsInactive
		0x006275FE, 0x0062764D, 0x0062767B, 0x00627AAD, 0x00627AFC, 0x00627B2A, // btlInitGroups2_3
		0x00626AD7, 0x00631F38, 0x00625C1A, 0x00625EBC, 0x00000000, // btlFileGetStr
		0x005B041A, 0x005B0463, 0x005B04AC, // btlLoadBack_3
		0x005AAE5A, 0x005AA96F, 0x005AAF1B, 0x00520A55, 0x0052B5F6, // pkg_entry_sub

		0x0049031C, 0x0056D42B, 0x005AF632, 0x0053D46B, // waitShowCursor
		0x0052FFA3, 0x00485168, 0x0048518A, 0x00485067, // msgTimeHook
		0x0048D5D7, 0x00405DC1, 0x0048ACB7, // print_deinit

		0x004509EC, 0x00450A79, 0x0040A69F, 0x00000000, // summoner_fix
		0x0055ED7D, 0x0047EF5B, 0x0052D52F, 0x0047EF5B, 0x0055EDE2, // interlockFix
		0x006CB6C4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, // radio_objects_create
		0x0056036C, 0x005C871F, 0x0053DDDF, 0x0053DEAB, // map_center_set

		0x005604A8, 0x0053A188, 0x0053A2DF, // mouse_pos_nop_2
		0x0042AF0F, 0x0042AF97, // endAiTurn
		0x0051AF91, 0x0051B049, // speed_map
		0x004F30E0, 0x004F065A, 0x004F2CA0, // async_ruin
		0x00651B58, 0x00651BA4, // sphere_y

		0x0082B47C, 0x00486C22, 0x00486D3F, 0x00832000, 0x005B0136, 0x005B01FB, 0x00000000, // banners_owner_trigger
		0x00534E63, 0x0052F05C, 0x004E6F0F, 0x004E60C2, 0x00000000, 0x0040406E, 0x0051C4D8, // str_print

		0x004012C1, 0x005C3E70, 0x005BA60E, 0x005BA8C9, // clouds_check
#pragma endregion

#pragma region v2_01
		// v2.01
		NUM(2, 01), VER(2003, 5, 16, 1),
		0x005645FC, 0x005C97D9, 0x0066FFC1,

		0x005BB2A9, 0x005A7434, 0x005BC059, 0x006758C0, 0x00675A27, 0x005A732C,
		0x006EA4E8, 0x0055E55E, 0x00676D96, 0x0055E6F4, 0x006E398C, 0x005B69F0,
		0x005B68F0, 0x00529178, 0x005AE075, 0x006E34C8, 0x005317C9, 0x00531862,
		0x00539521, 0x00539560, 0x00539569, 0x005395BB,

		0x0061331D, 0x00613381, 0x0040263B, 0x0053A1BD,
		0x00515A22, 0x00519FF0, 0x00515112, 0x005C829E, 0x005C825F, 0x00488C30, 0x004859E2,
		0x00515E2F, 0x00515F3E, 0x00669434,

		0x00546870, 0x0054789E, 0x005476F9, 0x00547344, 0x00546A5B, 0x005472F7,
		0x005482B9, 0x00549A1C, 0x00548721, 0x00547EF5, 0x00548443, 0x00548181, 0x005488F2, 0x00548FFC,

		0x0053E350, 0x0053EAC6, 0x00000000, 0x00000000, 0x0053EB68, 0x0053EA0B, 0x0053B927,

		0x00625C15, 0x0063FB98, 0x00626D03, 0x006265AF, 0x00629F9A, 0x00630BA4, 0x0062689D, 0x00630C38,
		0x0062752E, 0x0062757D, 0x006275AB, 0x006279DD, 0x00627A2C, 0x00627A5A,
		0x00626A07, 0x00631E68, 0x00625B4A, 0x00625DEC, 0x00000000,
		0x005B008C, 0x005B00D5, 0x005B011E,
		0x005AAACC, 0x005AA5E1, 0x005AAB8D, 0x00520625, 0x0052B1F3,

		0x0048FAB4, 0x0056CEEE, 0x005AF2A4, 0x0053D265,
		0x0052FD28, 0x00484900, 0x00484922, 0x004847FF,
		0x0048CD6F, 0x00405F03, 0x0048A44F,

		0x00450226, 0x004502B3, 0x0040A789, 0x00000000,
		0x0055E99C, 0x00507F20, 0x0052D0FA, 0x00507F20, 0x0055EA01,
		0x006CB6C4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x0055FF8B, 0x007A61E4, 0x0053DBD9, 0x0053DCA5,

		0x005600C7, 0x00539F4A, 0x0053A0A1,
		0x0042AE78, 0x0042AF00,
		0x0051ABC1, 0x0051AC79,
		0x004F2BD1, 0x004F014B, 0x004F2791,
		0x00651AE8, 0x00651B34,

		0x0082B42C, 0x004863BA, 0x004864D7, 0x00831FB0, 0x005AFDA8, 0x005AFE6D, 0x00000000,
		0x00534C77, 0x0052EC27, 0x004E69E7, 0x004E5B9A, 0x00000000, 0x004041B0, 0x0051C0A8,

		0x004012C1, 0x005C3B26, 0x005BA204, 0x005BA4BF,
#pragma endregion

#pragma region v2_01 - Steam
		// v2.01 - Steam
		NUM(2, 01), VER(2003, 5, 16, 1),
		0x00564D68, 0x005C9BFA, 0x00672351,

		0x005BB7DE, 0x005A79EA, 0x005BC568, 0x00663E55, 0x00663FBC, 0x005A78E2,
		0x006EA690, 0x0055EC4C, 0x006652F8, 0x0055EDE2, 0x006E39DC, 0x005B6F70,
		0x005B6E70, 0x0052983E, 0x005AE623, 0x006E3518, 0x00531EE5, 0x00531F7E,
		0x00539C09, 0x00539C48, 0x00539C51, 0x00539CA3,

		0x00613712, 0x00613776, 0x00402253, 0x0053A89E,
		0x00516222, 0x0051A760, 0x00515912, 0x005C86BF, 0x005C8680, 0x00488CC7, 0x00485A69,
		0x0051662F, 0x0051673E, 0x0066B804,

		0x00546F70, 0x00547F9E, 0x00547DF9, 0x00547A44, 0x0054715B, 0x005479F7,
		0x005489B9, 0x0054A11C, 0x00548E21, 0x005485F5, 0x00548B43, 0x00548881, 0x00548FF2, 0x005496FC,

		0x0053EA15, 0x0053F162, 0x00000000, 0x00000000, 0x0053F204, 0x0053F0A7, 0x0053C02B,

		0x00625FB5, 0x0063FE68, 0x006270A3, 0x0062694F, 0x0062A33A, 0x00630F44, 0x00626C3D, 0x00630FD8,
		0x006278CE, 0x0062791D, 0x0062794B, 0x00627D7D, 0x00627DCC, 0x00627DFA,
		0x00626DA7, 0x00632208, 0x00625EEA, 0x0062618C, 0x0050B3AF,
		0x005B065B, 0x005B06A4, 0x005B06ED,
		0x005AB022, 0x005AAB37, 0x005AB149, 0x00520D1B, 0x0052B8F8,

		0x0048FB37, 0x005AA77E, 0x005AF894, 0x0053D936,
		0x00530462, 0x00484960, 0x00484982, 0x0048485F,
		0x0048CE0E, 0x00405B80, 0x0048A4EE,

		0x0045010A, 0x00450197, 0x0040A4AE, 0x00000000,
		0x0055F08A, 0x00401A11, 0x0052D8BB, 0x0047E73B, 0x0055F0EF,
		0x006CB6F4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00560680, 0x007A7078, 0x0053E2A4, 0x0053E370,

		0x005607BC, 0x0053A632, 0x0053A789,
		0x0042AC9E, 0x0042AD26,
		0x0051B331, 0x0051B3E9,
		0x004F2BDD, 0x004F0194, 0x004F279D,
		0x00651AA8, 0x00651AF4,

		0x0082C40C, 0x00486441, 0x0048656A, 0x00832F98, 0x005B0398, 0x005B043C, 0x00000000,
		0x0053533C, 0x0052F3E8, 0x004E69DE, 0x004E5BA0, 0x00000000, 0x00403DFF, 0x0051C6FA,

		0x00000000, 0x005C3ECC, 0x005BA707, 0x005BA9C2,
#pragma endregion

#pragma region v2_02a
		// v2.02a
		NUM(2, 02), VER(2003, 10, 23, 1),
		0x00564C4C, 0x005C9B4B, 0x0066FFE1,

		0x005BB74F, 0x005A7BFA, 0x005BC465, 0x006758E0, 0x00675A47, 0x005A7AF2,
		0x006EA4F0, 0x0055EBAE, 0x00676DB6, 0x0055ED44, 0x006E398C, 0x005B6F90,
		0x005B6E90, 0x00529698, 0x005AE83B, 0x006E34C8, 0x00531C99, 0x00531D32,
		0x005399F1, 0x00539A30, 0x00539A39, 0x00539A8B,

		0x00613530, 0x00613594, 0x0040254B, 0x0053A68D,
		0x00515F52, 0x0051A520, 0x00515642, 0x005C8610, 0x005C85D1, 0x004892E5, 0x00486097,
		0x0051635F, 0x0051646E, 0x00669454,

		0x00546EC0, 0x00547EEE, 0x00547D49, 0x00547994, 0x005470AB, 0x00547947,
		0x00548909, 0x0054A06C, 0x00548D71, 0x00548545, 0x00548A93, 0x005487D1, 0x00548F42, 0x0054964C,

		0x0053E820, 0x0053EF96, 0x00000000, 0x00000000, 0x0053F038, 0x0053EEDB, 0x0053BDF7,

		0x00625D25, 0x0063FCA8, 0x00626E13, 0x006266BF, 0x0062A0AA, 0x00630CB4, 0x006269AD, 0x00630D48,
		0x0062763E, 0x0062768D, 0x006276BB, 0x00627AED, 0x00627B3C, 0x00627B6A,
		0x00626B17, 0x00631F78, 0x00625C5A, 0x00625EFC, 0x00000000,
		0x005B0852, 0x005B089B, 0x005B08E4,
		0x005AB292, 0x005AADA7, 0x005AB353, 0x00520B45, 0x0052B713,

		0x00490169, 0x0056D6B4, 0x005AFA6A, 0x0053D735,
		0x005301F8, 0x00484FB5, 0x00484FD7, 0x00484EB4,
		0x0048D424, 0x00405F19, 0x0048AB04,

		0x004506BD, 0x0045074A, 0x0040A79F, 0x00000000,
		0x0055EFEC, 0x0050844A, 0x0052D6B4, 0x0050844A, 0x0055F051,
		0x006CB6C4, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x005605DB, 0x007A6248, 0x0053E0A9, 0x0053E175,

		0x00560717, 0x0053A41A, 0x0053A571,
		0x0042AE8E, 0x0042AF16,
		0x0051B0F1, 0x0051B1A9,
		0x004F3268, 0x004F07E2, 0x004F2E28,
		0x00651BF8, 0x00651C44,

		0x0082B49C, 0x00486A6F, 0x00486B8C, 0x00832028, 0x005B056E, 0x005B0633, 0x00000000,
		0x00535147, 0x0052F1E1, 0x004E6F78, 0x004E612B, 0x00000000, 0x004041C6, 0x0051C5C1,

		0x004012D7, 0x005C3E98, 0x005BA6AA, 0x005BA965,
#pragma endregion

#pragma region v2_02b
		// v2.02b
		NUM(2, 02), VER(2003, 10, 23, 1),
		0x0056339D, 0x005C848D, 0x0066E831,

		0x005B9F86, 0x005A6311, 0x005BACE1, 0x0067427E, 0x00674400, 0x005A6209,
		0x006E9408, 0x0055D283, 0x00675771, 0x0055D419, 0x006E2894, 0x005B5660,
		0x005B5560, 0x005280D9, 0x005ACF11, 0x006E23D0, 0x0053056A, 0x00530603,
		0x0053835D, 0x0053839C, 0x005383A5, 0x005383F7,

		0x00611C8B, 0x00611CEF, 0x00402129, 0x00538FEB,
		0x00514DD2, 0x005193F0, 0x005144C2, 0x005C6F52, 0x005C6F13, 0x00489124, 0x00485ED6,
		0x005151DF, 0x005152EE, 0x00667DC4,

		0x00545670, 0x0054669E, 0x005464F9, 0x00546144, 0x0054585B, 0x005460F7,
		0x005470B9, 0x0054881C, 0x00547521, 0x00546CF5, 0x00547243, 0x00546F81, 0x005476F2, 0x00547DFC,

		0x0053D185, 0x0053D8A9, 0x00000000, 0x00000000, 0x0053D94B, 0x0053D7EE, 0x0053A73D,

		0x00624595, 0x0063E6B8, 0x00625683, 0x00624F2F, 0x0062891A, 0x0062F524, 0x0062521D, 0x0062F5B8,
		0x00625EAE, 0x00625EFD, 0x00625F2B, 0x0062635D, 0x006263AC, 0x006263DA,
		0x00625387, 0x006307E8, 0x006244CA, 0x0062476C, 0x00000000,
		0x005AEF44, 0x005AEF8D, 0x005AEFD6,
		0x005A9957, 0x005A946C, 0x005A9A1E, 0x0051F886, 0x0052A14E,

		0x0048FF90, 0x004F146A, 0x005AE161, 0x0053C095,
		0x0052EAAE, 0x00484DD1, 0x00484DF3, 0x00484CD0,
		0x0048D25C, 0x00405A1A, 0x0048A93C,

		0x00450417, 0x004504A4, 0x0040A438, 0x00000000,
		0x0055D6C1, 0x004018E2, 0x0052C062, 0x0046F4D9, 0x0055D726,
		0x006CA61C, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x0055ECCC, 0x005C7089, 0x0053CA0E, 0x0053CADA,

		0x0055EE08, 0x00538D86, 0x00538EDD,
		0x0042AC64, 0x0042ACEC,
		0x00519FF1, 0x0051A0A9, // TODO time fix
		0x004F21C0, 0x004EF722, 0x004F1D80,
		0x00650628, 0x00650674,

		0x008293AC, 0x004868AE, 0x004869CB, 0x0082FF38, 0x005AEC65, 0x005AED25, 0x00000000,
		0x005339EE, 0x0052DB6A, 0x004E66AF, 0x004E584B, 0x00000000, 0x00403C7D, 0x0051B292,

		0x00000000, 0x005C277F, 0x005B8F00, 0x005B91BB,
#pragma endregion

#pragma region v3_00
		// v3.00
		NUM(3, 00), VER(2003, 11, 3, 1),
		0x00566D63, 0x005CCEBA, 0x00678551,

		0x005BE937, 0x005AAA7C, 0x005BF68F, 0x0067DE67, 0x0067DFD5, 0x005AA974,
		0x006F3E38, 0x00560D76, 0x0067F364, 0x00560F0C, 0x006ECE64, 0x005BA160,
		0x005BA060, 0x0052C1CA, 0x005B1654, 0x006EC998, 0x00534793, 0x0053482C,
		0x0053C4E5, 0x0053C524, 0x0053C52D, 0x0053C57F,

		0x006190FD, 0x00619162, 0x00402482, 0x0053D170,
		0x005188B2, 0x0051CE80, 0x00517FA2, 0x005CB97F, 0x005CB940, 0x0048BCF3, 0x00488954,
		0x00518CBF, 0x00518DCE, 0x006719E4,

		0x005497C0, 0x0054A7EE, 0x0054A649, 0x0054A294, 0x005499AB, 0x0054A247,
		0x0054B209, 0x0054C96C, 0x0054B671, 0x0054AE45, 0x0054B393, 0x0054B0D1, 0x0054B842, 0x0054BF4C,

		0x005412F7, 0x00541A4A, 0x00000000, 0x00000000, 0x00541AEC, 0x0054198F, 0x0053E8DC,

		0x0062CCE5, 0x00646BF8, 0x0062DE6E, 0x0062D6E8, 0x0063123E, 0x006381F8, 0x0062DA08, 0x0063831D,
		0x0062E75B, 0x0062E7A8, 0x0062E7D6, 0x0062EC09, 0x0062EC5C, 0x0062EC90,
		0x0062DB72, 0x00639607, 0x0062CC1A, 0x0062CF25, 0x00000000,
		0x005B36B5, 0x005B36FE, 0x005B3747,
		0x005AE0F0, 0x005ADC05, 0x005AE19F, 0x00523484, 0x0052E252,

		0x00492B0A, 0x00403FF6, 0x005B28DA, 0x00540212,
		0x00532D35, 0x00487853, 0x00487875, 0x00487752,
		0x0048FDA8, 0x00405C18, 0x0048D4BE,

		0x004520F6, 0x00452183, 0x0040A66F, 0x006266FE,
		0x005611B4, 0x0055B71C, 0x005301EB, 0x0055B71C, 0x00561219,
		0x006D4974, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x005627B8, 0x005CBAB6, 0x00540B86, 0x00540C52,

		0x005628F4, 0x0053CF0E, 0x0053D065,
		0x0042BD23, 0x0042BDAB,
		0x0051DA41, 0x0051DAF9,
		0x004F5656, 0x004F2BB9, 0x004F5216,
		0x00658D78, 0x00658DC4,

		0x00835AAC, 0x0048916A, 0x0048927A, 0x00838688, 0x005B33DE, 0x005B3482, 0x00000000,
		0x00537C14, 0x00531D04, 0x004EA19F, 0x004E9352, 0x00000000, 0x00403FA0, 0x0051EE45,

		0x004012D4, 0x005C7162, 0x005BD8EA, 0x005BDBA5,
#pragma endregion

#pragma region v3_00 - Steam
		// v3.00 - Steam
		NUM(3, 00), VER(2003, 11, 3, 1),
		0x005674DE, 0x005CD93F, 0x00678C51,

		0x005BF272, 0x005AB0A4, 0x005C0048, 0x0067E78C, 0x0067E8D5, 0x005AAF9C,
		0x006F4E40, 0x005614BE, 0x0067FC5F, 0x00561654, 0x006EDE44, 0x005BA970,
		0x005BA870, 0x0052CB61, 0x005B1CE2, 0x006ED978, 0x00534FFD, 0x00535096,
		0x0053CD9E, 0x0053CDDD, 0x0053CDE6, 0x0053CE38,

		0x00619B3D, 0x00619BA2, 0x004021CE, 0x0053DA29,
		0x00519372, 0x0051D940, 0x00518A62, 0x005CC404, 0x005CC3C5, 0x0048BF6E, 0x00488BB0,
		0x0051977F, 0x0051988E, 0x006721C4,

		0x00549EE0, 0x0054AF0E, 0x0054AD69, 0x0054A9B4, 0x0054A0CB, 0x0054A967,
		0x0054B929, 0x0054D08C, 0x0054BD91, 0x0054B565, 0x0054BAB3, 0x0054B7F1, 0x0054BF62, 0x0054C66C,

		0x00541BA5, 0x005422C9, 0x00000000, 0x00000000, 0x0054236B, 0x0054220E, 0x0053F1A4,

		0x0062D6C5, 0x00647508, 0x0062E84E, 0x0062E0C8, 0x00631C1E, 0x00638BD8, 0x0062E3E8, 0x00638CFD,
		0x0062F13B, 0x0062F188, 0x0062F1B6, 0x0062F5E9, 0x0062F63C, 0x0062F670,
		0x0062E552, 0x00639FE7, 0x0062D5FA, 0x0062D905, 0x0050E535,
		0x005B3D11, 0x005B3D5A, 0x005B3DA3,
		0x005AE718, 0x005AE22D, 0x005AE82D, 0x00523F93, 0x0052EBD2,

		0x00492DB4, 0x00581521, 0x005B2F1A, 0x00540AC6,
		0x00533515, 0x00487AAD, 0x00487ACF, 0x004879AC,
		0x00490052, 0x00405929, 0x0048D732,

		0x0045257F, 0x0045260C, 0x0040A3D9, 0x006270CE,
		0x005618FC, 0x00401989, 0x00530AA9, 0x004722EF, 0x00561961,
		0x006D5934, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00562EF2, 0x007B296C, 0x00541434, 0x00541500,

		0x0056302E, 0x0053D7C7, 0x0053D91E,
		0x0042BF1B, 0x0042BFA3,
		0x0051E501, 0x0051E5B9,
		0x004F57C4, 0x004F2D6D, 0x004F5384,
		0x00659398, 0x006593E4,

		0x00837E7C, 0x004893E9, 0x004894F5, 0x0083AA58, 0x005B3A1E, 0x005B3ADE, 0x00000000,
		0x0053842D, 0x005325B2, 0x004EA2D3, 0x004E9495, 0x00000000, 0x00403CB9, 0x0051F84D,

		0x00000000, 0x005C7C18, 0x005BE1F5, 0x005BE4B0,
#pragma endregion

#pragma region v3_01a
		// v3.01a and Crack
		NUM(3, 01), VER(2003, 12, 11, 1),
		0x005676DA, 0x005CDF6F, 0x00679991,

		0x005BF7E4, 0x005AB6D8, 0x005C0654, 0x0067F2BE, 0x0067F42A, 0x005AB5D0,
		0x006F5E50, 0x005616BE, 0x006807FE, 0x00561854, 0x006EEE74, 0x005BAFC0,
		0x005BAEC0, 0x0052CAA6, 0x005B22A1, 0x006EE9A8, 0x00535048, 0x005350E1,
		0x0053CE21, 0x0053CE60, 0x0053CE69, 0x0053CEBB,

		0x0061A6C5, 0x0061A72A, 0x00402444, 0x0053DAAC,
		0x005191B2, 0x0051D6E0, 0x005188A2, 0x005CCA34, 0x005CC9F5, 0x0048BF35, 0x00488B9E,
		0x005195BF, 0x005196CE, 0x00672E84,

		0x0054A0E0, 0x0054B10E, 0x0054AF69, 0x0054ABB4, 0x0054A2CB, 0x0054AB67,
		0x0054BB29, 0x0054D28C, 0x0054BF91, 0x0054B765, 0x0054BCB3, 0x0054B9F1, 0x0054C162, 0x0054C86C,

		0x00541C2D, 0x0054237C, 0x00000000, 0x00000000, 0x0054241E, 0x005422C1, 0x0053F237,

		0x0062E345, 0x006482A8, 0x0062F4CE, 0x0062ED48, 0x0063289E, 0x00639858, 0x0062F068, 0x0063997D,
		0x0062FDBB, 0x0062FE08, 0x0062FE36, 0x00630269, 0x006302BC, 0x006302F0,
		0x0062F1D2, 0x0063AC67, 0x0062E27A, 0x0062E585, 0x00000000,
		0x005B4308, 0x005B4351, 0x005B439A,
		0x005AED4C, 0x005AE861, 0x005AEDFB, 0x00523D50, 0x0052EB29,

		0x00492EEA, 0x00403FC0, 0x005B3528, 0x00540B48,
		0x005335EC, 0x00487AB9, 0x00487ADB, 0x004879B8,
		0x004900C8, 0x00405C95, 0x0048D7A8,

		0x004526E8, 0x00452775, 0x0040A79D, 0x00627CEE,
		0x00561AFC, 0x005E4830, 0x00530AE7, 0x005E4830, 0x00561B61,
		0x006D6984, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x0056310E, 0x007B2740, 0x005414BC, 0x00541588,

		0x0056324A, 0x0053D84A, 0x0053D9A1,
		0x0042C330, 0x0042C3B8,
		0x0051E2B1, 0x0051E369,
		0x004F5FD7, 0x004F355B, 0x004F5B97,
		0x0065A018, 0x0065A064,

		0x00837ACC, 0x004893B4, 0x004894BC, 0x0083A6A8, 0x005B402C, 0x005B40D5, 0x00000000,
		0x005384C4, 0x0053260D, 0x004EAA85, 0x004E9C47, 0x00000000, 0x00403F62, 0x0051F785,

		0x0040127A, 0x005C818B, 0x005BE762, 0x005BEA1D,
#pragma endregion

#pragma region v3_01b
		// v3.01b
		NUM(3, 01), VER(2003, 12, 11, 1),
		0x00566E04, 0x005CCE8B, 0x006781F1,

		0x005BE82F, 0x005AA960, 0x005BF589, 0x0067DC5A, 0x0067DDDC, 0x005AA858,
		0x006F3E00, 0x00560E5B, 0x0067F172, 0x00560FF1, 0x006ECE14, 0x005B9F70,
		0x005B9E70, 0x0052C03C, 0x005B15A2, 0x006EC948, 0x00534626, 0x005346BF,
		0x0053C4CD, 0x0053C50C, 0x0053C515, 0x0053C567,

		0x006191E3, 0x00619248, 0x0040218A, 0x0053D158,
		0x00518742, 0x0051CCA0, 0x00517E32, 0x005CB950, 0x005CB911, 0x0048BB1E, 0x00488787,
		0x00518B4F, 0x00518C5E, 0x00671694,

		0x005497F0, 0x0054A81E, 0x0054A679, 0x0054A2C4, 0x005499DB, 0x0054A277,
		0x0054B239, 0x0054C99C, 0x0054B6A1, 0x0054AE75, 0x0054B3C3, 0x0054B101, 0x0054B872, 0x0054BF7C,

		0x005412DD, 0x00541A01, 0x00000000, 0x00000000, 0x00541AA3, 0x00541946, 0x0053E89F,

		0x0062CD85, 0x00646B28, 0x0062DF0E, 0x0062D788, 0x006312DE, 0x00638298, 0x0062DAA8, 0x006383BD,
		0x0062E7FB, 0x0062E848, 0x0062E876, 0x0062ECA9, 0x0062ECFC, 0x0062ED30,
		0x0062DC12, 0x006396A7, 0x0062CCBA, 0x0062CFC5, 0x00000000,
		0x005B35EA, 0x005B3633, 0x005B367C,
		0x005ADFD4, 0x005ADAE9, 0x005AE0BF, 0x005231F2, 0x0052E0E7,

		0x00492942, 0x0041B1B3, 0x005B27EE, 0x005401F9,
		0x00532B79, 0x0048768A, 0x004876AC, 0x00487589,
		0x0048FBCC, 0x00405921, 0x0048D2E2,

		0x004520B4, 0x00452141, 0x0040A3F9, 0x0062682E,
		0x00561299, 0x00401943, 0x00530014, 0x0055B7BC, 0x005612FE,
		0x006D4924, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x005628A4, 0x007B06F0, 0x00540B6C, 0x00540C38,

		0x005629E0, 0x0053CEF6, 0x0053D04D,
		0x0042BD4D, 0x0042BDD5,
		0x0051D871, 0x0051D929,
		0x004F53DF, 0x004F2990, 0x004F4F9F,
		0x00658A98, 0x00658AE4,

		0x00835A7C, 0x00488F9D, 0x004890A5, 0x00838650, 0x005B32F2, 0x005B33B7, 0x00000000,
		0x00537ACC, 0x00531B25, 0x004E9F37, 0x004E90E2, 0x00000000, 0x00403C8B, 0x0051EB96,

		0x00000000, 0x005C7174, 0x005BD7EA, 0x005BDAA5,
#pragma endregion

#pragma region v2_00 Editor - Steam
		// v2.00 Editor - Steam
		NUM(2, 00), VER(2003, 5, 13, 1),
		0x00489D24, 0x004D4257, 0x004B7025,

		0x0055C4B6, 0x0054C79A, 0x0055D13A, 0x00591E06, 0x00591F6A, 0x0054C68E,
		0x005DEDE0, 0x0057F12A, 0x005932E9, 0x0057F2C0, 0x005DC574, 0x005568D0,
		0x005567D0, 0x004BFB0E, 0x0055429D, 0x005DBFA8, 0x0048CA22, 0x0048CABB,
		0x0058097B, 0x005809BA, 0x005809C3, 0x00580A15,

		0x0051B64F, 0x0051B6B3, 0x00000000, 0x0049435D,
		0x004AF3B2, 0x004B38E0, 0x004AEAA2, 0x004D2597, 0x004D2558, 0x00000000, 0x00000000,
		0x004AF7BF, 0x004AF8CE, 0x00584EE4,

		0x0056D0D0, 0x0056E0FE, 0x0056DF59, 0x0056DBA4, 0x0056D2BB, 0x0056DB57,
		0x0056EB19, 0x0057027C, 0x0056EF81, 0x0056E755, 0x0056ECA3, 0x0056E9E1, 0x0056F152, 0x0056F85C,

		0x00499B8E, 0x0049A2D0, 0x00448D1C, 0x0046320E, 0x0049A372, 0x0049A215, 0x00496D92,

		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x0048500E, 0x005225DB, 0x00489FEC, 0x005225DB, 0x00485073,
		0x005CA40C, 0x005CBF34, 0x005CBA6C, 0x005CC4A4, 0x005CE40C, 0x004A1872,
		0x004897CA, 0x0064DEC8, 0x00499417, 0x004994E3,

		0x00489906, 0x004940EA, 0x00494241,
		0x00000000, 0x00000000,
		0x004B43C1, 0x004B4479,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x0065E520, 0x0055E93A, 0x00000000, 0x0044D014,
		0x004903E5, 0x00495435, 0x004F066C, 0x004166BC, 0x00415D6B, 0x00403156, 0x004B65A9,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
#pragma endregion

#pragma region v2_01 Editor
		// v2.01 Editor
		NUM(2, 01), VER(2003, 5, 16, 1),
		0x004893BC, 0x004D38B1, 0x004B66EB,

		0x0055B9F7, 0x0054C08C, 0x0055C66B, 0x00591270, 0x005913E0, 0x0054BF84,
		0x005DDD70, 0x0057E23F, 0x005927BD, 0x0057E3D5, 0x005DB524, 0x00555F10,
		0x00555E10, 0x004BF0E2, 0x005538E4, 0x005DAF58, 0x0048C109, 0x0048C1A2,
		0x0057FA99, 0x0057FAD8, 0x0057FAE1, 0x0057FB33,

		0x0051ADF0, 0x0051AE54, 0x00000000, 0x00493A1D,
		0x004AEAC2, 0x004B2FE0, 0x004AE1B2, 0x004D1BF1, 0x004D1BB2, 0x00000000, 0x00000000,
		0x004AEECF, 0x004AEFDE, 0x005842E4,

		0x0056C1D0, 0x0056D1FE, 0x0056D059, 0x0056CCA4, 0x0056C3BB, 0x0056CC57,
		0x0056DC19, 0x0056F37C, 0x0056E081, 0x0056D855, 0x0056DDA3, 0x0056DAE1, 0x0056E252, 0x0056E95C,

		0x0049925F, 0x00499A08, 0x00448D8C, 0x0046346A, 0x00499AAA, 0x0049994D, 0x00496412,

		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x004846B4, 0x00547DC7, 0x00489684, 0x00547DC7, 0x00484719,
		0x005C93BC, 0x005CAEE4, 0x005CAA1C, 0x005CB454, 0x005CD394, 0x004A0F63,
		0x00488ECB, 0x0064CC34, 0x00498AE8, 0x00498BB4,

		0x00489007, 0x004937B8, 0x0049390F,
		0x00000000, 0x00000000,
		0x004B3AE1, 0x004B3B99,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x0065CD48, 0x0055DD64, 0x00000000, 0x0044D09A,
		0x0048FADD, 0x00494AED, 0x004EFD1B, 0x0041683E, 0x00415ED5, 0x004030B3, 0x004B5C57,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
#pragma endregion

#pragma region v2_02a Editor
		// v2.02 Editor
		NUM(2, 02), VER(2003, 10, 23, 1),
		0x004893BC, 0x004D38B1, 0x004B66EB,

		0x0055BB17, 0x0054C1AC, 0x0055C78B, 0x00591379, 0x005914E9, 0x0054C0A4,
		0x005DDD78, 0x0057E35F, 0x005928C6, 0x0057E4F5, 0x005DB52C, 0x00556030,
		0x00555F30, 0x004BF0E2, 0x00553A04, 0x005DAF60, 0x0048C109, 0x0048C1A2,
		0x0057FBB9, 0x0057FBF8, 0x0057FC01, 0x0057FC53,

		0x0051AE07, 0x0051AE6B, 0x00000000, 0x00493A1D,
		0x004AEAC2, 0x004B2FE0, 0x004AE1B2, 0x004D1BF1, 0x004D1BB2, 0x00000000, 0x00000000,
		0x004AEECF, 0x004AEFDE, 0x00584404,

		0x0056C2F0, 0x0056D31E, 0x0056D179, 0x0056CDC4, 0x0056C4DB, 0x0056CD77,
		0x0056DD39, 0x0056F49C, 0x0056E1A1, 0x0056D975, 0x0056DEC3, 0x0056DC01, 0x0056E372, 0x0056EA7C,

		0x0049925F, 0x00499A08, 0x00448D8C, 0x0046346A, 0x00499AAA, 0x0049994D, 0x00496412,

		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x004846B4, 0x00547EE7, 0x00489684, 0x00547EE7, 0x00484719,
		0x005C93BC, 0x005CAEE4, 0x005CAA1C, 0x005CB454, 0x005CD394, 0x004A0F63,
		0x00488ECB, 0x0064CC38, 0x00498AE8, 0x00498BB4,

		0x00489007, 0x004937B8, 0x0049390F,
		0x00000000, 0x00000000,
		0x004B3AE1, 0x004B3B99,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x0065CD70, 0x0055DE84, 0x00000000, 0x0044D09A,
		0x0048FADD, 0x00494AED, 0x004EFD1B, 0x0041683E, 0x00415ED5, 0x004030B3, 0x004B5C57,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
#pragma endregion

#pragma region v2_02b Editor
		// v2.02 Editor
		NUM(2, 02), VER(2003, 10, 23, 1),
		0x004890B9, 0x004D3828, 0x004B647D,

		0x0055B94A, 0x0054BE12, 0x0055C5D2, 0x0059109B, 0x005911FF, 0x0054BD0A,
		0x005DDD40, 0x0057E15F, 0x005925A0, 0x0057E2F5, 0x005DB4EC, 0x00555D80,
		0x00555C80, 0x004BF013, 0x00553749, 0x005DAF20, 0x0048BDB8, 0x0048BE51,
		0x0057F9AB, 0x0057F9EA, 0x0057F9F3, 0x0057FA45,

		0x0051ACC1, 0x0051AD25, 0x00000000, 0x004936DF,
		0x004AE7B2, 0x004B2D20, 0x004ADEA2, 0x004D1B68, 0x004D1B29, 0x00000000, 0x00000000,
		0x004AEBBF, 0x004AECCE, 0x005841D4,

		0x0056C0F0, 0x0056D11E, 0x0056CF79, 0x0056CBC4, 0x0056C2DB, 0x0056CB77,
		0x0056DB39, 0x0056F29C, 0x0056DFA1, 0x0056D775, 0x0056DCC3, 0x0056DA01, 0x0056E172, 0x0056E87C,

		0x00498F85, 0x004996F6, 0x00448C9A, 0x004633C5, 0x00499798, 0x0049963B, 0x0049613D,

		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00484411, 0x0052F4E0, 0x00489381, 0x0052F4E0, 0x00484476,
		0x005C93AC, 0x005CAED4, 0x005CAA0C, 0x005CB444, 0x005CD384, 0x004A0C7F,
		0x00488BCB, 0x0064CC48, 0x0049880E, 0x004988DA,

		0x00488D07, 0x0049347A, 0x004935D1,
		0x00000000, 0x00000000,
		0x004B3811, 0x004B38C9,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x0065CD70, 0x0055DBFD, 0x00000000, 0x0044CFB0,
		0x0048F771, 0x004947D4, 0x004EFBAC, 0x0041675B, 0x00415DE8, 0x004030A1, 0x004B59E9,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
#pragma endregion

#pragma region v3_00 Editor - Steam
		// v3.00 Editor - Steam
		NUM(3, 00), VER(2003, 11, 3, 1),
		0x0048C841, 0x004D71D0, 0x004B9C35,

		0x0056234B, 0x005527FA, 0x00562FDC, 0x00597EDA, 0x00598050, 0x005526EE,
		0x005E6700, 0x00585176, 0x005993B6, 0x0058530C, 0x005E3E24, 0x0055C7D0,
		0x0055C6D0, 0x004C264A, 0x0055A1A3, 0x005E3850, 0x0048F5B3, 0x0048F64C,
		0x005869CA, 0x00586A09, 0x00586A12, 0x00586A64,

		0x0052019C, 0x00520201, 0x00000000, 0x00496F6F,
		0x004B1F82, 0x004B64F0, 0x004B1672, 0x004D550E, 0x004D54CF, 0x00000000, 0x00000000,
		0x004B238F, 0x004B249E, 0x0058AF54,

		0x00573120, 0x0057414E, 0x00573FA9, 0x00573BF4, 0x0057330B, 0x00573BA7,
		0x00574B69, 0x005762CC, 0x00574FD1, 0x005747A5, 0x00574CF3, 0x00574A31, 0x005751A2, 0x005758AC,

		0x0049C83A, 0x0049CF68, 0x0044AB98, 0x0046555C, 0x0049D00A, 0x0049CEAD, 0x004999FB,

		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00487BDB, 0x0055FF24, 0x0048CB09, 0x0055FF24, 0x00487C40,
		0x005D1774, 0x005D32FC, 0x005D2DFC, 0x005D386C, 0x005D58D4, 0x004A44F5,
		0x0048C354, 0x006574A4, 0x0049C0C3, 0x0049C18F,

		0x0048C490, 0x00496D06, 0x00496E5D,
		0x00000000, 0x00000000,
		0x004B7001, 0x004B70B9,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00667E44, 0x0056480E, 0x00000000, 0x0044EE74,
		0x00493001, 0x004980CE, 0x004F48C9, 0x004169C0, 0x0041606F, 0x00403195, 0x004B91B6,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
#pragma endregion

#pragma region v3_01 Editor
		// v3.01 Editor
		NUM(3, 01), VER(2003, 12, 11, 1),
		0x0048BA1A, 0x004D642A, 0x004B8BFF,

		0x00561820, 0x00551CA9, 0x005624CD, 0x00597125, 0x0059728C, 0x00551BA1,
		0x005E5660, 0x0058422F, 0x005986BD, 0x005843C5, 0x005E2D9C, 0x0055BCF0,
		0x0055BBF0, 0x004C1729, 0x0055969C, 0x005E27C8, 0x0048E6DF, 0x0048E778,
		0x00585A83, 0x00585AC2, 0x00585ACB, 0x00585B1D,

		0x0051F560, 0x0051F5C5, 0x00000000, 0x0049604C,
		0x004B1002, 0x004B5560, 0x004B06F2, 0x004D4768, 0x004D4729, 0x00000000, 0x00000000,
		0x004B140F, 0x004B151E, 0x0058A1B4,

		0x005721C0, 0x005731EE, 0x00573049, 0x00572C94, 0x005723AB, 0x00572C47,
		0x00573C09, 0x0057536C, 0x00574071, 0x00573845, 0x00573D93, 0x00573AD1, 0x00574242, 0x0057494C,

		0x0049B857, 0x0049BFFF, 0x0044A8E6, 0x00465353, 0x0049C0A1, 0x0049BF44, 0x00498A27,

		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00000000,
		0x00486DD7, 0x00534AA4, 0x0048BCE2, 0x00534AA4, 0x00486E3C,
		0x005D0714, 0x005D229C, 0x005D1D9C, 0x005D280C, 0x005D484C, 0x004A3549,
		0x0048B529, 0x00656180, 0x0049B0E0, 0x0049B1AC,

		0x0048B665, 0x00495DEA, 0x00495F41,
		0x00000000, 0x00000000,
		0x004B6051, 0x004B6109,
		0x00000000, 0x00000000, 0x00000000,
		0x00000000, 0x00000000,

		0x00000000, 0x00000000, 0x00000000, 0x00666484, 0x00563C2D, 0x00000000, 0x0044EBD5,
		0x0049209B, 0x004970EC, 0x004F3C0C, 0x0041670E, 0x00415DBD, 0x00403079, 0x004B816B,

		0x00000000, 0x00000000, 0x00000000, 0x00000000
#pragma endregion
	};

	// ===============================================================
	BEGINLOCK sub_BeginLock;
	ENDLOCK sub_EndLock;

	BEGINLOCK sub_BeginLock_2;
	ENDLOCK sub_EndLock_2;

	HWND hWndMain;
	UINT uAiMsg;

	DWORD aiTime;
	VOID BeginAI()
	{
		config.ai.timeout = TRUE;
		aiTime = timeGetTime();
	}

	VOID CheckAI()
	{
		if (timeGetTime() - aiTime >= 2000)
			config.ai.timeout = FALSE;
	}

	WNDPROC OldWindowProc;
	LRESULT __stdcall WindowProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
	{
		LRESULT res = CallWindowProc(OldWindowProc, hWnd, uMsg, wParam, lParam);
		if (uMsg == WM_TIMER)
		{
			CheckAI();

			while (config.ai.fast && config.ai.thinking)
			{
				Sleep(0);
				MSG msg;
				if (PeekMessage(&msg, hWnd, NULL, NULL, PM_REMOVE) && msg.message != WM_TIMER)
				{
					res = CallWindowProc(OldWindowProc, hWnd, msg.message, msg.wParam, msg.lParam);
					if (msg.message == uAiMsg)
						BeginAI();
					else if (msg.message == WM_QUIT || msg.message == WM_CLOSE || msg.message == WM_DESTROY)
						break;
				}
				else
				{
					res = CallWindowProc(OldWindowProc, hWnd, uMsg, wParam, lParam);
					CheckAI();
				}
			}
		}
		else if (uMsg == uAiMsg)
			BeginAI();

		return res;
	}

	UINT __stdcall RegisterWindowMessageHook(LPCSTR lpString)
	{
		static WinMessage* messages;

		WinMessage* msg = messages;
		while (msg && StrCompare(msg->name, lpString))
			msg = msg->prev;

		if (!msg)
		{
			msg = (WinMessage*)MemoryAlloc(sizeof(WinMessage));
			msg->id = 0;
			msg->name = StrDuplicate(lpString);
			msg->prev = messages;
			messages = msg;
		}

		if (!msg->id)
			msg->id = RegisterWindowMessage(lpString);

		if (!StrCompare(lpString, "AIMESSAGE"))
			uAiMsg = msg->id;

		return msg->id;
	}

	HWND __stdcall CreateWindowExHook(DWORD dwExStyle, LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, INT X, INT Y, INT nWidth, INT nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance, LPVOID lpParam)
	{
		BOOL isMain = !StrCompare(lpClassName, "MQ_UIManager");
		if (isMain)
		{
			dwStyle = WS_WINDOWED;
			RECT rect = { 0, 0, (LONG)config.mode->width, (LONG)config.mode->height };
			AdjustWindowRect(&rect, dwStyle, TRUE);

			nWidth = rect.right - rect.left;
			nHeight = rect.bottom - rect.top;

			X = (GetSystemMetrics(SM_CXSCREEN) - nWidth) >> 1;
			if (X < 0)
				X = 0;

			Y = (GetSystemMetrics(SM_CYSCREEN) - nHeight) >> 1;
			if (Y < 0)
				Y = 0;
		}

		HWND hWnd = CreateWindowEx(dwExStyle, lpClassName, lpWindowName, dwStyle, X, Y, nWidth, nHeight, hWndParent, hMenu, hInstance, lpParam);
		if (isMain)
		{
			hWndMain = hWnd;

			if (config.windowedMode)
				SetMenu(hWnd, config.menu);
		}
		else if (!StrCompare(lpClassName, "ThreadWindowClass"))
			OldWindowProc = (WNDPROC)SetWindowLong(hWnd, GWL_WNDPROC, (LPARAM)WindowProc);

		return hWnd;
	}

	ATOM __stdcall RegisterClassHook(WNDCLASSA* lpWndClass)
	{
		if (!StrCompare(lpWndClass->lpszClassName, "MQ_UIManager"))
		{
			config.cursor = lpWndClass->hCursor;
			config.icon = lpWndClass->hIcon;
			lpWndClass->hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
		}

		return RegisterClass(lpWndClass);
	}

	LONG __stdcall SetWindowLongHook(HWND hWnd, INT nIndex, LONG dwNewLong)
	{
		if (hWnd == hWndMain)
		{
			if (nIndex == GWL_WNDPROC)
			{
				LONG res = SetWindowLong(hWnd, nIndex, dwNewLong);
				Window::SetCaptureWindow(hWnd);
				return res;
			}

			if (nIndex == GWL_STYLE)
				dwNewLong = WS_FULLSCREEN;
		}

		return SetWindowLong(hWnd, nIndex, dwNewLong);
	}

	HWND __stdcall GetForegroundWindowHook()
	{
		HWND hWnd = GetForegroundWindow();
		OpenDraw* ddraw = Main::FindOpenDrawByWindow(hWnd);
		return ddraw ? ddraw->hWnd : hWnd;
	}

	INT_PTR __stdcall DialogBoxParamHook(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND, DLGPROC lpDialogFunc, LPARAM dwInitParam)
	{
		INT_PTR res;
		DialogParams params = { hWndMain, TRUE, NULL };
		Window::BeginDialog(&params);
		{
			res = DialogBoxParam(hInstance, lpTemplateName, params.hWnd, lpDialogFunc, dwInitParam);
		}
		Window::EndDialog(&params);
		return res;
	}

	INT __stdcall MessageBoxHook(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
	{
		INT res;
		DialogParams params = { hWndMain, TRUE, NULL };
		Window::BeginDialog(&params);
		{
			res = MessageBox(hWnd, lpText, lpCaption, uType);
		}
		Window::EndDialog(&params);
		return res;
	}

	BOOL __stdcall GetOpenFileNameHook(LPOPENFILENAMEA lpofn)
	{
		BOOL res;
		DialogParams params = { hWndMain, TRUE, NULL };
		Window::BeginDialog(&params);
		{
			res = GetOpenFileName(lpofn);
		}
		Window::EndDialog(&params);
		return res;
	}

	BOOL __stdcall GetSaveFileNameHook(LPOPENFILENAMEA lpofn)
	{
		BOOL res;
		DialogParams params = { hWndMain, TRUE, NULL };
		Window::BeginDialog(&params);
		{
			res = GetSaveFileName(lpofn);
		}
		Window::EndDialog(&params);
		return res;
	}

	INT __stdcall ShowCursorHook(BOOL bShow)
	{
		return bShow ? 1 : -1;
	}

	BOOL __stdcall ClipCursorHook(RECT*)
	{
		return TRUE;
	}

	BOOL __stdcall GetClientRectHook(HWND hWnd, LPRECT lpRect)
	{
		if (hWnd == hWndMain)
		{
			lpRect->left = 0;
			lpRect->top = 0;
			lpRect->right = config.mode->width;
			lpRect->bottom = config.mode->height;
			return TRUE;
		}
		else
			return GetClientRect(hWnd, lpRect);
	}

	BOOL __stdcall GetWindowRectHook(HWND hWnd, LPRECT lpRect)
	{
		if (GetWindowRect(hWnd, lpRect))
		{
			if (hWnd == hWndMain)
			{
				RECT rect = { 0, 0, *(LONG*)&config.mode->width, *(LONG*)&config.mode->height };
				AdjustWindowRect(&rect, config.windowedMode ? WS_WINDOWED : WS_FULLSCREEN, config.windowedMode);

				lpRect->right = lpRect->left + rect.right - rect.left;
				lpRect->bottom = lpRect->top + rect.bottom - rect.top;
			}

			return TRUE;
		}

		return FALSE;
	}

	BOOL __stdcall GetCursorPosHookV1(LPPOINT lpPoint)
	{
		OpenDraw* ddraw = Main::FindOpenDrawByWindow(GetForegroundWindow());
		if (ddraw)
		{
			if (GetCursorPos(lpPoint))
			{
				RECT rect;
				if (GetClientRect(hWndMain, &rect) && ClientToScreen(hWndMain, (LPPOINT)&rect))
				{
					if (!config.windowedMode && config.borderless.mode)
						rect.bottom -= BORDERLESS_OFFSET;

					FLOAT fx = (FLOAT)config.mode->width / rect.right;
					FLOAT fy = (FLOAT)config.mode->height / rect.bottom;

					POINTFLOAT offset = { 0.0f, 0.0f };
					if (config.image.aspect && fx != fy)
					{
						if (fx < fy)
						{
							fx = fy;
							offset.x = ((FLOAT)rect.right - (FLOAT)config.mode->width / fx) * 0.5f;
						}
						else
						{
							fy = fx;
							offset.y = ((FLOAT)rect.bottom - (FLOAT)config.mode->height / fy) * 0.5f;
						}
					}

					if (!Config::IsZoomed())
					{
						lpPoint->x = LONG(fx * (FLOAT(lpPoint->x - rect.left) - offset.x));
						lpPoint->y = LONG(fy * (FLOAT(lpPoint->y - rect.top) - offset.y));
					}
					else
					{
						FLOAT kx = config.zoom.sizeFloat.width / config.mode->width;
						FLOAT ky = config.zoom.sizeFloat.height / config.mode->height;

						lpPoint->x = LONG(fx * kx * (FLOAT(lpPoint->x - rect.left) - offset.x) + ((FLOAT)config.mode->width - config.zoom.sizeFloat.width) * 0.5f);
						lpPoint->y = LONG(fy * kx * (FLOAT(lpPoint->y - rect.top) - offset.y) + ((FLOAT)config.mode->height - config.zoom.sizeFloat.height) * 0.5f);
					}

					if (lpPoint->x < 0)
						lpPoint->x = 0;

					if (lpPoint->y < 0)
						lpPoint->y = 0;

					if (lpPoint->x >= *(INT*)&config.mode->width)
						lpPoint->x = *(INT*)&config.mode->width - 1;

					if (lpPoint->y >= *(INT*)&config.mode->height)
						lpPoint->y = *(INT*)&config.mode->height - 1;
				}

				return TRUE;
			}

			return FALSE;
		}
		else
		{
			lpPoint->x = config.mode->width >> 1;
			lpPoint->y = config.mode->height >> 1;
			return TRUE;
		}
	}

	BOOL __stdcall GetCursorPosHookV2(LPPOINT lpPoint)
	{
		static POINT last;

		OpenDraw* ddraw = Main::FindOpenDrawByWindow(GetForegroundWindow());
		if (ddraw)
		{
			if (GetCursorPos(lpPoint))
			{
				RECT rect;
				if (GetClientRect(hWndMain, &rect) && ClientToScreen(hWndMain, (LPPOINT)&rect))
				{
					if (!config.windowedMode && config.borderless.mode)
						rect.bottom -= BORDERLESS_OFFSET;

					FLOAT fx = (FLOAT)config.mode->width / rect.right;
					FLOAT fy = (FLOAT)config.mode->height / rect.bottom;

					POINTFLOAT offset = { 0.0f, 0.0f };
					if (config.image.aspect && fx != fy)
					{
						if (fx < fy)
						{
							fx = fy;
							offset.x = ((FLOAT)rect.right - (FLOAT)config.mode->width / fx) * 0.5f;
						}
						else
						{
							fy = fx;
							offset.y = ((FLOAT)rect.bottom - (FLOAT)config.mode->height / fy) * 0.5f;
						}
					}

					if (!Config::IsZoomed())
					{
						lpPoint->x = LONG(fx * (FLOAT(lpPoint->x - rect.left) - offset.x)) + rect.left;
						lpPoint->y = LONG(fy * (FLOAT(lpPoint->y - rect.top) - offset.y)) + rect.top;
					}
					else
					{
						FLOAT kx = config.zoom.sizeFloat.width / config.mode->width;
						FLOAT ky = config.zoom.sizeFloat.height / config.mode->height;

						lpPoint->x = LONG(fx * kx * (FLOAT(lpPoint->x - rect.left) - offset.x) + ((FLOAT)config.mode->width - config.zoom.sizeFloat.width) * 0.5f) + rect.left;
						lpPoint->y = LONG(fy * kx * (FLOAT(lpPoint->y - rect.top) - offset.y) + ((FLOAT)config.mode->height - config.zoom.sizeFloat.height) * 0.5f) + rect.top;
					}

					last = *lpPoint;
				}

				return TRUE;
			}

			return FALSE;
		}
		else
		{
			*lpPoint = last;
			return FALSE;
		}
	}

	DWORD sub_GetCursorPos;
	LPPOINT __fastcall GetCursorPosHookV2a(VOID* obj, DWORD /*edx*/, LPPOINT lpPoint)
	{
		if (config.windowedMode)
		{
			OpenDraw* ddraw = Main::FindOpenDrawByWindow(GetForegroundWindow());
			if (ddraw)
			{
				GetCursorPos(lpPoint);

				if (lpPoint->x < 3)
					lpPoint->x = 0;
				else if (lpPoint->x >= GetSystemMetrics(SM_CXSCREEN) - 3)
					lpPoint->x = config.mode->width;
				else
					lpPoint->x = config.mode->width >> 1;

				if (lpPoint->y < 3)
					lpPoint->y = 0;
				else if (lpPoint->y >= GetSystemMetrics(SM_CYSCREEN) - 3)
					lpPoint->y = config.mode->height;
				else
					lpPoint->y = config.mode->height >> 1;
			}
			else
			{
				lpPoint->x = config.mode->width >> 1;
				lpPoint->y = config.mode->height >> 1;
			}

			return lpPoint;
		}

		return ((LPPOINT(__thiscall*)(VOID*, LPPOINT))sub_GetCursorPos)(obj, lpPoint);
	}

	BOOL __stdcall SetCursorPosHook(INT X, INT Y)
	{
		RECT rect;
		if (GetClientRect(hWndMain, &rect) && ClientToScreen(hWndMain, (LPPOINT)&rect))
		{
			if (!config.windowedMode && config.borderless.mode)
				rect.bottom -= BORDERLESS_OFFSET;

			FLOAT fx = (FLOAT)rect.right / config.mode->width;
			FLOAT fy = (FLOAT)rect.bottom / config.mode->height;

			POINTFLOAT offset = { 0.0f, 0.0f };
			if (config.image.aspect && fx != fy)
			{
				if (fx > fy)
				{
					fx = fy;
					offset.x = ((FLOAT)rect.right - (fx * config.mode->width)) * 0.5f;
				}
				else
				{
					fy = fx;
					offset.y = ((FLOAT)rect.bottom - (fy * config.mode->height)) * 0.5f;
				}
			}

			if (!Config::IsZoomed())
			{
				X = LONG(fx * FLOAT(X - rect.left) + offset.x) + rect.left;
				Y = LONG(fy * FLOAT(Y - rect.top) + offset.y) + rect.top;
			}
			else
			{
				FLOAT kx = (FLOAT)config.mode->width / config.zoom.sizeFloat.width;
				FLOAT ky = (FLOAT)config.mode->height / config.zoom.sizeFloat.height;

				X = LONG(fx * kx * (FLOAT(X - rect.left) - ((FLOAT)config.mode->width - config.zoom.sizeFloat.width) * 0.5f) + offset.x) + rect.left;
				Y = LONG(fy * ky * (FLOAT(Y - rect.top) - ((FLOAT)config.mode->height - config.zoom.sizeFloat.height) * 0.5f) + offset.y) + rect.top;
			}
		}

		return SetCursorPos(X, Y);
	}

	BOOL __stdcall ClientToScreenHook(HWND hWnd, LPPOINT lpPoint)
	{
		if (hWnd == hWndMain)
			return TRUE;

		return ClientToScreen(hWnd, lpPoint);
	}

	INT __stdcall GetDeviceCapsHook(HDC hdc, INT index)
	{
		if (index == BITSPIXEL)
			return 16;

		return GetDeviceCaps(hdc, index);
	}

	const CLSID CLSID_DirectDraw = { 0xD7B70EE0, 0x4340, 0x11CF, 0xB0, 0x63, 0x00, 0x20, 0xAF, 0xC2, 0xCD, 0x35 };
	HRESULT __stdcall CoCreateInstanceHook(REFCLSID rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, REFIID riid, LPVOID* ppv)
	{
		if (!MemoryCompare(&rclsid, &CLSID_DirectDraw, sizeof(CLSID)))
			return Main::DrawCreateEx(NULL, ppv, riid, NULL);

		return CoCreateInstance(rclsid, pUnkOuter, dwClsContext, riid, ppv);
	}

#pragma region 32 BPP
	DWORD pBinkCopyToBuffer;
	LONG __stdcall BinkCopyToBufferHook(VOID* hBnk, DWORD* dst, DWORD pitch, DWORD height, DWORD x, DWORD y, DWORD flags)
	{
		LONG res = ((LONG(__stdcall*)(VOID*, DWORD*, DWORD, DWORD, DWORD, DWORD, DWORD))pBinkCopyToBuffer)(hBnk, dst, pitch << 1, height, x, y, BINKCOPYALL | (config.renderer == RendererGDI ? BINKSURFACE32 : BINKSURFACE32R));
		if (!res)
		{
			pitch >>= 1;

			if (config.isSSE2)
			{
				if (!(pitch & 0xF))
				{
					__m128i* d = (__m128i*)dst;
					__m128i k = _mm_set1_epi32(ALPHA_COMPONENT);

					DWORD c = height * (pitch >> 2);
					if ((DWORD)dst & 0xF)
					{
						do
							_mm_storeu_si128(d++, _mm_or_si128(_mm_loadu_si128(d), k));
						while (--c);
					}
					else
					{
						do
							_mm_store_si128(d++, _mm_or_si128(_mm_load_si128(d), k));
						while (--c);
					}
				}
				else
				{
					DWORD width = pitch;
					DWORD count = width >> 2;
					if (count)
					{
						DWORD step = width - (count << 2);

						__m128i* d = (__m128i*)dst;
						__m128i k = _mm_set1_epi32(ALPHA_COMPONENT);

						DWORD h = height;
						do
						{
							DWORD w = count;
							do
								_mm_storeu_si128(d++, _mm_or_si128(_mm_loadu_si128(d), k));
							while (--w);

							d = (__m128i*)((DWORD*)d + step);
						} while (--h);

						count <<= 2;
						width -= count;
						dst += count;
					}

					pitch -= width;
					do
					{
						DWORD count = width;
						do
							*dst++ |= ALPHA_COMPONENT;
						while (--count);

						dst += pitch;
					} while (--height);
				}
			}
			else
			{
				DWORD c = height * pitch;
				do
					*dst++ |= ALPHA_COMPONENT;
				while (--c);
			}
		}

		return res;
	}

#pragma region Memory
	VOID __declspec(naked) hook_005A6311()
	{
		__asm {
			shl eax, 0x1
			imul eax, [esi+0x4]
			pop edx
			push ebx
			push edx
			retn
		}
	}

	DWORD back_005BACE7;
	VOID __declspec(naked) hook_005BACE1()
	{
		__asm {
			shl eax, 0x2
			imul eax, [ebp-0x14]
			jmp back_005BACE7
		}
	}

	VOID __declspec(naked) hook_00674400()
	{
		__asm {
			shl eax, 0x1
			imul eax, [edi+0x4]
			pop edx
			push eax
			push edx
			retn
		}
	}

	VOID __declspec(naked) hook_005A6209()
	{
		__asm
		{
			pop edi
			push 0x0
			push edi
			xor edi, edi
			shl eax, 0x2
			retn
		}
	}
#pragma endregion

#pragma region PIXEL
	DWORD __fastcall ConvertToRGB(DWORD color)
	{
		return ((color & 0x001F) << 19) | ((color & 0x07E0) << 5) | ((color & 0xF800) >> 8) | ALPHA_COMPONENT;
	}

	DWORD __fastcall ConvertToBGR(DWORD color)
	{
		return ((color & 0x001F) << 3) | ((color & 0x07E0) << 5) | ((color & 0xF800) << 8) | ALPHA_COMPONENT;
	}

	DWORD(__fastcall* Convert565toRGB)
	(DWORD color);

	DWORD __inline Blend(DWORD dstData, DWORD srcData, DWORD msk)
	{
		DWORD res;

		msk &= 0x000000FF;

		if (msk == 255)
			res = srcData;
		else if (msk)
		{
			++msk;

			DWORD src = srcData & 0x000000FF;
			DWORD dst = dstData & 0x000000FF;
			res = (dst + ((src - dst) * msk) / 256) & 0x000000FF;

			src = srcData & 0x0000FF00;
			dst = dstData & 0x0000FF00;
			res |= (dst + ((src - dst) * msk) / 256) & 0x0000FF00;

			src = srcData & 0x00FF0000;
			dst = dstData & 0x00FF0000;
			res |= (dst + ((src - dst) * msk) / 256) & 0x00FF0000;
		}
		else
			res = dstData;

		return res | ALPHA_COMPONENT;
	}

	VOID __stdcall Pixel_Blit_Indexed_to_565(BYTE* srcData, DWORD srcPitch, DWORD* palette, DWORD* dstData, DWORD dstPitch, RECT* rect)
	{
		BYTE* lpSrc = srcData + rect->top * srcPitch + rect->left;
		dstPitch >>= 1;
		DWORD* lpDst = dstData + rect->top * dstPitch + rect->left;

		DWORD width = rect->right - rect->left;
		DWORD height = rect->bottom - rect->top;

		if (config.renderer == RendererGDI)
		{
			do
			{
				BYTE* src = lpSrc;
				DWORD* dst = lpDst;

				DWORD count = width;
				do
					*dst++ = _byteswap_ulong(_rotl(palette[*src++], 8)) | ALPHA_COMPONENT;
				while (--count);

				lpSrc += srcPitch;
				lpDst += dstPitch;
			} while (--height);
		}
		else
		{
			do
			{
				BYTE* src = lpSrc;
				DWORD* dst = lpDst;

				DWORD count = width;
				do
					*dst++ = palette[*src++] | ALPHA_COMPONENT;
				while (--count);

				lpSrc += srcPitch;
				lpDst += dstPitch;
			} while (--height);
		}
	}

	DWORD __stdcall Pixel_ConvertPixel_565(BYTE red, BYTE green, BYTE blue)
	{
		return (blue >> 3) | (green >> 3 << 6) | (red >> 3 << 11);
	}

	VOID __stdcall Pixel_Blit_By_Masks(DWORD* srcData, LONG srcPitch, DWORD redMask, DWORD greenMask, DWORD blueMask, DWORD alphaMask, BYTE* dstData, LONG dstPitch, RECT* rect)
	{
		srcPitch >>= 1;

		if (dstPitch & 3)
			dstPitch = (dstPitch & 0xFFFFFFFC) + 4;

		srcData += rect->top * srcPitch + rect->left;

		if (!Config::IsZoomed())
			dstData += rect->top * dstPitch + rect->left * 3;

		LONG height = rect->bottom - rect->top;
		do
		{
			BYTE* src = (BYTE*)srcData;
			BYTE* dst = dstData;

			LONG width = rect->right - rect->left;
			do
			{
				*dst++ = *++src;
				*dst++ = *++src;
				*dst++ = *++src;

				++src;
			} while (--width);

			srcData += srcPitch;
			dstData += dstPitch;
		} while (--height);
	}

	VOID __stdcall Pixel_ConvertPixel_565_to_RGB(DWORD color, BYTE* red, BYTE* green, BYTE* blue)
	{
		BYTE* px = (BYTE*)&color;

		*red = *px++;
		*green = *px++;
		*blue = *px;
	}

	VOID __stdcall Pixel_Blit_RGB_to_565(BYTE* srcData, DWORD srcPitch, DWORD* dstData, DWORD dstPitch, RECT* rect)
	{
		dstPitch >>= 1;

		srcData += rect->left + rect->top * srcPitch;
		dstData += rect->left + rect->top * dstPitch;

		DWORD height = rect->bottom - rect->top;
		do
		{
			BYTE* src = srcData;
			BYTE* dst = (BYTE*)dstData;

			DWORD width = rect->right - rect->left;
			do
			{
				*dst++ = *src++;
				*dst++ = *src++;
				*dst++ = *src++;
				*dst++ = 0xFF;
			} while (--width);

			srcData += srcPitch;
			dstData += dstPitch;
		} while (--height);
	}

	VOID __stdcall Pixel_RGB_Swap(BYTE* data, LONG pitch, SIZE* size)
	{
		if (config.renderer == RendererGDI && size->cx && size->cy)
		{
			DWORD height = size->cy;
			do
			{
				BYTE* px = data;

				DWORD width = size->cx;
				do
				{
					BYTE temp = *(px + 2);
					*(px + 2) = *px;
					*px = temp;

					px += 3;
				} while (--width);

				data += pitch;
			} while (--height);
		}
	}

	DWORD __stdcall Pixel_Blend(DWORD dstData, DWORD srcData, DWORD msk)
	{
		return Blend(dstData, srcData, msk);
	}

	DWORD __stdcall Pixel_BlendSome(DWORD pix, BYTE b, BYTE g, BYTE r, BYTE msk)
	{
		return Blend(pix, r | (g << 8) | (b << 16), msk);
	}

	VOID __stdcall Pixel_BlitBlend(DWORD* srcData, DWORD* dstData, DWORD count, BYTE* mskData)
	{
		for (; count; --count)
		{
			*dstData = Blend(*dstData, *srcData, *(BYTE*)mskData);

			++srcData;
			++dstData;
			++mskData;
		}
	}

	VOID __stdcall Pixel_BlitBlendWithColorKey(BlendData* blendItem, DWORD count, DWORD colorKey)
	{
		if (count)
		{
			colorKey = Convert565toRGB(colorKey);

			do
			{
				if (blendItem->length)
				{
					DWORD* srcData = blendItem->srcData;
					DWORD* dstData = blendItem->dstData;
					BYTE* mskData = blendItem->mskData;

					DWORD length = blendItem->length;
					do
					{
						if ((*dstData & COLORKEY_AND) != colorKey)
							*dstData = Blend(*dstData, *srcData, *(BYTE*)mskData);

						++srcData;
						++dstData;
						++mskData;
					} while (--length);
				}

				++blendItem;
			} while (--count);
		}
	}

	VOID __stdcall Pixel_BlitBlendAvarage(DWORD* src, LONG srcPitch, POINT* srcPos, DWORD* dst, LONG dstPitch, POINT* dstPos, SIZE* size, BYTE flag, DWORD colorKey)
	{
		if (!flag || !dst || !size->cx || !size->cy)
			return;

		colorKey = Convert565toRGB(colorKey);
		srcPitch >>= 1;
		dstPitch >>= 1;

		src += srcPitch * srcPos->y + srcPos->x;
		dst += dstPitch * dstPos->y + dstPos->x;

		srcPitch -= size->cx;
		dstPitch -= size->cx;

		DWORD height = size->cy;
		do
		{
			DWORD width = size->cx;
			do
			{
				if ((*src & COLORKEY_AND) != colorKey)
					*dst = Blend(*dst, *src, flag);

				++src;
				++dst;
			} while (--width);

			src += srcPitch;
			dst += dstPitch;
		} while (--height);
	}

	VOID __stdcall Pixel_Add(DWORD* src, LONG srcPitch, POINT* srcPos, DWORD* dst, LONG dstPitch, POINT* dstPos, SIZE* size)
	{
		if (!dst || !size->cx || !size->cy)
			return;

		srcPitch >>= 1;
		dstPitch >>= 1;

		src += srcPitch * srcPos->y + srcPos->x;
		dst += dstPitch * dstPos->y + dstPos->x;

		srcPitch -= size->cx;
		dstPitch -= size->cx;

		DWORD height = size->cy;
		do
		{
			DWORD width = size->cx;
			do
			{
				DWORD cs = *src++;
				DWORD cd = *dst;

				DWORD r = (cd & 0x000000FF) + (cs & 0x000000FF);
				if (r > 0x000000FF)
					r = 0x000000FF;

				DWORD g = (cd & 0x0000FF00) + (cs & 0x0000FF00);
				if (g > 0x0000FF00)
					g = 0x0000FF00;

				DWORD b = (cd & 0x00FF0000) + (cs & 0x00FF0000);
				if (b > 0x00FF0000)
					b = 0x00FF0000;

				*dst++ = r | g | b | ALPHA_COMPONENT;
			} while (--width);

			src += srcPitch;
			dst += dstPitch;
		} while (--height);
	}

	VOID __stdcall Pixel_Sub(DWORD* src, LONG srcPitch, POINT* srcPos, DWORD* dst, LONG dstPitch, POINT* dstPos, SIZE* size)
	{
		if (!dst || !size->cx || !size->cy)
			return;

		srcPitch >>= 1;
		dstPitch >>= 1;

		src += srcPitch * srcPos->y + srcPos->x;
		dst += dstPitch * dstPos->y + dstPos->x;

		srcPitch -= size->cx;
		dstPitch -= size->cx;

		DWORD height = size->cy;
		do
		{
			DWORD width = size->cx;
			do
			{
				DWORD cs = *src++;
				DWORD cd = *dst;

				INT r = (cd & 0x000000FF) - (cs & 0x000000FF);
				if (r < 0)
					r = 0;

				INT g = (cd & 0x0000FF00) - (cs & 0x0000FF00);
				if (g < 0)
					g = 0;

				INT b = (cd & 0x00FF0000) - (cs & 0x00FF0000);
				if (b < 0)
					b = 0;

				*dst++ = r | g | b | ALPHA_COMPONENT;
			} while (--width);

			src += srcPitch;
			dst += dstPitch;
		} while (--height);
	}

	VOID __stdcall Pixel_BlitColorKey(DWORD* srcData, LONG srcPitch, POINT* srcPos, DWORD* dstData, LONG dstPitch, POINT* dstPos, SIZE* size, BYTE flag, DWORD colorKey)
	{
		if (!flag || !dstData || !size->cx || !size->cy)
			return;

		flag = min(255, flag * 2);

		colorKey = Convert565toRGB(colorKey);
		srcPitch >>= 1;
		dstPitch >>= 1;

		srcData += srcPitch * srcPos->y + srcPos->x;
		dstData += dstPitch * dstPos->y + dstPos->x;

		BOOL check = (~dstPos->y ^ dstPos->x) & 1;

		DWORD height = size->cy;
		do
		{
			DWORD* src = srcData;
			DWORD* dst = dstData;

			DWORD width = size->cx;
			if (check)
			{
				++src;
				++dst;
				--width;
			}

			for (DWORD i = (width + 1) >> 1; i; --i)
			{
				if ((*src & COLORKEY_AND) != colorKey)
					*dst = Blend(*dst, *src, flag);

				src += 2;
				dst += 2;
			}

			srcData += srcPitch;
			dstData += dstPitch;

			check = !check;
		} while (--height);
	}

	VOID __stdcall Pixel_BlitEmptyColor(DWORD* srcData, LONG srcPitch, POINT* srcPos, DWORD* dstData, LONG dstPitch, POINT* dstPos, SIZE* size)
	{
		if (!dstData || !size->cx || !size->cy)
			return;

		srcPitch >>= 1;
		dstPitch >>= 1;

		srcData += srcPitch * srcPos->y + srcPos->x;
		dstData += dstPitch * dstPos->y + dstPos->x;

		BOOL check = (~dstPos->y ^ dstPos->x) & 1;

		DWORD height = size->cy;
		do
		{
			DWORD* src = srcData;
			DWORD* dst = dstData;

			DWORD width = size->cx;
			if (check)
			{
				++src;
				++dst;
				--width;
			}

			for (DWORD i = (width + 1) >> 1; i; --i)
			{
				if (*src & COLORKEY_AND)
					*dst = *src;

				src += 2;
				dst += 2;
			}

			srcData += srcPitch;
			dstData += dstPitch;

			check = !check;
		} while (--height);
	}

	VOID __stdcall Pixel_DoubleLighter(DWORD* data, LONG pitch, SIZE* size, DWORD colorKey, BYTE flag)
	{
		if (!size->cx || !size->cy)
			return;

		colorKey = Convert565toRGB(colorKey);
		pitch >>= 1;
		pitch -= size->cx;

		DWORD height = size->cy;
		do
		{
			DWORD width = size->cx;
			do
			{
				if ((*data & COLORKEY_AND) == colorKey)
					*data = 0;
				else if (flag)
				{
					DWORD r = *data & 0xFF;
					DWORD g = (*data >> 8) & 0xFF;
					DWORD b = (*data >> 16) & 0xFF;

					if (r + g + b > 56)
					{
						r <<= 1;
						if (r > 0xFF)
							r = 0xFF;

						g <<= 1;
						if (g > 0xFF)
							g = 0xFF;

						b <<= 1;
						if (b > 0xFF)
							b = 0xFF;

						*data = r | (g << 8) | (b << 16) | (*data & 0xFF000000);
					}
					else
						*data = 0;
				}

				++data;
			} while (--width);

			data += pitch;
		} while (--height);
	}

	const VOID* const pixelFunctions[] = {
		Pixel_Blit_Indexed_to_565,
		Pixel_ConvertPixel_565,
		Pixel_Blit_By_Masks,
		Pixel_ConvertPixel_565_to_RGB,
		Pixel_Blit_RGB_to_565,
		Pixel_RGB_Swap,
		Pixel_BlendSome,
		Pixel_Blend,
		Pixel_BlitBlend,
		Pixel_BlitBlendWithColorKey,
		Pixel_BlitBlendAvarage,
		Pixel_Add,
		Pixel_Sub,
		Pixel_BlitColorKey,
		Pixel_BlitEmptyColor,
		Pixel_DoubleLighter
	};
#pragma endregion

	BOOL Clip(POINT* shift, POINT* pt, SIZE* size, RECT* clipper)
	{
		if (pt->x < clipper->left)
		{
			size->cx += pt->x - clipper->left;
			shift->x += clipper->left - pt->x;
			pt->x = clipper->left;
		}

		if (pt->x + size->cx > clipper->right)
			size->cx = clipper->right - pt->x;

		if (pt->y < clipper->top)
		{
			size->cy += pt->y - clipper->top;
			shift->y += clipper->top - pt->y;
			pt->y = clipper->top;
		}

		if (pt->y + size->cy > clipper->bottom)
			size->cy = clipper->bottom - pt->y;

		return size->cx > 0 && size->cy > 0;
	}

	VOID __fastcall DrawMinimapObjects(BlitObject* obj, DWORD /*edx*/, VOID* data, RECT* rect, DWORD pitch, DWORD colorKey, POINT* loc)
	{
		if (data && rect->left <= rect->right && rect->top <= rect->bottom && (colorKey <= (obj->isTrueColor ? 0xFFFFu : 0xFFu) || colorKey == 0xFFFFFFFF))
		{
			POINT shift = *(POINT*)rect;
			POINT pt = *loc;
			SIZE size = { rect->right - rect->left, rect->bottom - rect->top };

			if (Clip(&shift, &pt, &size, &obj->rect))
			{
				if (colorKey == 0xFFFFFFFF)
				{
					if (obj->isTrueColor)
					{
						DWORD srcPitch = pitch >> 1;
						DWORD dstPitch = obj->pitch >> 1;

						DWORD* srcData = (DWORD*)data + shift.y * srcPitch + shift.x;
						DWORD* dstData = (DWORD*)obj->data + pt.y * dstPitch + pt.x;

						do
						{
							MemoryCopy(dstData, srcData, size.cx << 2);
							dstData += dstPitch;
							srcData += srcPitch;
						} while (--size.cy);
					}
					else
					{
						DWORD srcPitch = pitch;
						DWORD dstPitch = obj->pitch;

						BYTE* srcData = (BYTE*)data + shift.y * srcPitch + shift.x;
						BYTE* dstData = (BYTE*)obj->data + pt.y * dstPitch + pt.x;

						do
						{
							MemoryCopy(dstData, srcData, size.cx);
							dstData += dstPitch;
							srcData += srcPitch;
						} while (--size.cy);
					}
				}
				else
				{
					if (obj->isTrueColor)
					{
						colorKey = Convert565toRGB(colorKey);

						DWORD srcPitch = pitch >> 1;
						DWORD dstPitch = obj->pitch >> 1;

						DWORD* srcData = (DWORD*)data + shift.y * srcPitch + shift.x;
						DWORD* dstData = (DWORD*)obj->data + pt.y * dstPitch + pt.x;

						if (config.renderer == RendererGDI)
						{
							do
							{
								DWORD* src = srcData;
								DWORD* dst = dstData;

								DWORD count = size.cx;
								do
								{
									if ((*src & COLORKEY_AND) != colorKey)
										*dst = *src;

									++src;
									++dst;
								} while (--count);

								dstData += dstPitch;
								srcData += srcPitch;
							} while (--size.cy);
						}
						else
						{
							do
							{
								DWORD* src = srcData;
								DWORD* dst = dstData;

								DWORD count = size.cx;
								do
								{
									if ((*src & COLORKEY_AND) != colorKey)
										*dst = _byteswap_ulong(_rotl(*src, 8)); // swap for map objects

									++src;
									++dst;
								} while (--count);

								dstData += dstPitch;
								srcData += srcPitch;
							} while (--size.cy);
						}
					}
					else
					{
						DWORD srcPitch = pitch;
						DWORD dstPitch = obj->pitch;

						BYTE* srcData = (BYTE*)data + shift.y * srcPitch + shift.x;
						BYTE* dstData = (BYTE*)obj->data + pt.y * dstPitch + pt.x;

						do
						{
							BYTE* src = srcData;
							BYTE* dst = dstData;

							DWORD count = size.cx;
							do
							{
								if (*src != colorKey)
									*dst = *src;

								++src;
								++dst;
							} while (--count);

							dstData += dstPitch;
							srcData += srcPitch;
						} while (--size.cy);
					}
				}
			}
		}
	}

	VOID __fastcall FillColor(BlitObject* obj, DWORD /*edx*/, DWORD color, RECT* rect)
	{
		LONG width = rect->right - rect->left;
		LONG height = rect->bottom - rect->top;

		if (width && height)
		{
			if (obj->isTrueColor)
			{
				color = Convert565toRGB(color);
				DWORD pitch = obj->pitch >> 1;
				DWORD* data = (DWORD*)obj->data + rect->top * pitch + rect->left;
				pitch -= width;
				do
				{
					DWORD count = width;
					do
						*data++ = color;
					while (--count);

					data += pitch;
				} while (--height);
			}
			else
			{
				DWORD pitch = obj->pitch;
				BYTE* data = (BYTE*)obj->data + rect->top * pitch + rect->left;
				pitch -= width;
				do
				{
					DWORD count = width;
					do
						*data++ = LOBYTE(color);
					while (--count);

					data += pitch;
				} while (--height);
			}
		}
	}

	VOID __fastcall DrawWaterBorders(DWORD* thisObj, DWORD /*edx*/, BlitObject* obj, POINT* loc, RECT* rect)
	{
		DWORD pitch = obj->pitch >> 1;

		DWORD* srcData = (*(DWORD * (__thiscall**)(DWORD*))((*thisObj) + 12))(thisObj);
		DWORD* dstData = (DWORD*)obj->data + loc->y * pitch;

		LONG offset = 30;
		LONG width = 2;

		LONG idx = 0;
		do
		{
			LONG y = loc->y + idx;
			if (y >= rect->top && y < rect->bottom)
			{
				LONG srcX = offset;
				LONG size = width;

				LONG dstX = loc->x + srcX;

				if (dstX < rect->left)
				{
					size += dstX - rect->left;
					srcX += rect->left - dstX;
					dstX = 0;
				}

				if (size >= rect->right - dstX)
					size = rect->right - dstX;

				if (size > 0)
				{
					DWORD* src = srcData + srcX;
					DWORD* dst = dstData + dstX;
					do
					{
						if ((*src & COLORKEY_AND) != COLORKEY_CHECK)
							*dst = *src;

						++src;
						++dst;
					} while (--size);
				}
			}

			if (++idx == 32)
				return;

			if (idx < 16)
			{
				offset -= 2;
				width += 4;
			}
			else if (idx != 16)
			{
				offset += 2;
				width -= 4;
			}

			srcData += 64;
			dstData += pitch;
		} while (TRUE);
	}

	VOID __fastcall DrawGround(DWORD* thisObj, DWORD /*edx*/, BlitObject* obj, POINT* srcLoc, POINT* dstLoc, RECT* rect, BYTE* blendMask, DWORD* alphaMask)
	{
		static BlendData blendList[32];

		DWORD pitch = obj->pitch >> 1;

		DWORD* srcData = **(DWORD***)thisObj[1] + srcLoc->y * 192;
		DWORD* dstData = (DWORD*)obj->data + dstLoc->y * pitch;

		BlendData* blendItem = blendList;
		DWORD blendCount = 0;

		LONG offset = 30;
		LONG width = 2;

		LONG idx = 0;
		do
		{
			LONG srcY = srcLoc->y + idx;
			LONG dstY = dstLoc->y + idx;

			if (srcY >= 0 && srcY < 192 && dstY >= rect->top && dstY < rect->bottom)
			{
				LONG srcX = offset + srcLoc->x;
				LONG dstX = offset + dstLoc->x;

				LONG off = offset;
				LONG size = width;

				if (srcX < 0)
				{
					size += srcX;
					off = offset - srcX;
					dstX -= srcX;
					srcX = 0;
				}

				if (dstX < rect->left)
				{
					size += dstX - rect->left;
					off += rect->left - dstX;
					srcX += rect->left - dstX;
					dstX = 0;
				}

				if (size >= 192 - srcX)
					size = 192 - srcX;

				if (size >= rect->right - dstX)
					size = rect->right - dstX;

				if (size > 0)
				{
					if (blendMask) // Water
					{
						blendItem->srcData = srcData + srcX;
						blendItem->dstData = dstData + dstX;
						blendItem->length = size;
						blendItem->mskData = blendMask + (idx * 64) + off;

						++blendCount;
						++blendItem;
					}
					else if (alphaMask)
					{
						DWORD* msk = alphaMask + (idx * 32) + off;
						DWORD* src = srcData + srcX;
						DWORD* dst = dstData + dstX;

						do
						{
							DWORD pix = *msk;
							if ((pix & COLORKEY_AND) != COLORKEY_CHECK)
							{
								if ((pix & COLORKEY_AND) == 0x00F8FC80)
									pix = *src;

								*dst = pix;
							}

							++msk;
							++src;
							++dst;
						} while (--size);
					}
					else // ground
						MemoryCopy(dstData + dstX, srcData + srcX, size * sizeof(DWORD));
				}
			}

			if (++idx == 32)
				break;

			if (idx < 16)
			{
				offset -= 2;
				width += 4;
			}
			else if (idx != 16)
			{
				offset += 2;
				width -= 4;
			}

			srcData += 192;
			dstData += pitch;
		} while (TRUE);

		if (blendCount)
			Pixel_BlitBlendWithColorKey(blendList, blendCount, 0xF81F);
	}

	VOID __stdcall ClearGround(BlitObject* obj, POINT* loc, RECT* rect)
	{
		DWORD pitch = obj->pitch >> 1;

		DWORD* dstData = (DWORD*)obj->data + loc->y * pitch;

		LONG offset = 30;
		LONG width = 2;

		LONG idx = 0;
		do
		{
			LONG y = loc->y + idx;
			if (y >= rect->top && y < rect->bottom)
			{
				LONG dstX = loc->x + offset;
				LONG size = width;

				if (dstX < rect->left)
				{
					size += dstX - rect->left;
					dstX = 0;
				}

				if (size >= rect->right - dstX)
					size = rect->right - dstX;

				if (size > 0)
				{
					DWORD* dst = dstData + dstX;
					do
						*dst++ = ALPHA_COMPONENT;
					while (--size);
				}
			}

			if (++idx == 32)
				return;

			if (idx < 16)
			{
				offset -= 2;
				width += 4;
			}
			else if (idx != 16)
			{
				offset += 2;
				width -= 4;
			}

			dstData += pitch;
		} while (TRUE);
	}

	VOID __fastcall DrawSymbol(DWORD* obj, DWORD /*edx*/, DWORD* data, LONG dstPitch, POINT pt, RECT* clipper, RECT* rect, DWORD colorFill, DWORD colorShadow, BYTE castShadow, CHAR symbol)
	{
		if (symbol != '\n' && symbol != '\r')
		{
			LONG* font = *(LONG**)(*obj + 4 * *(BYTE*)&symbol + 16);

			POINT shift = { 0, 0 };
			SIZE size = { font[0], font[1] };

			if (Clip(&shift, &pt, &size, clipper))
			{
				colorFill = Convert565toRGB(colorFill);
				colorShadow = Convert565toRGB(colorShadow);

				DWORD srcPitch = font[3];
				BYTE* src = (BYTE*)font[4] + shift.y * srcPitch + (shift.x >> 3);

				DWORD mod = shift.x % 8;
				if (!mod)
					mod = 8;

				dstPitch >>= 1;
				DWORD* dst = (DWORD*)data + pt.y * dstPitch + pt.x;

				LONG height = size.cy;
				LONG y = pt.y;
				do
				{
					BYTE* srcPtr = src;
					BYTE srcVal = *srcPtr << (8 - mod);
					DWORD mask = mod;

					DWORD* dstPtr = dst;

					LONG width = size.cx;
					LONG x = pt.x;
					do
					{
						if (srcVal & 0x80)
						{
							*dstPtr = colorFill;

							if (castShadow)
							{
								if (x > rect->left && *(dstPtr - 1) != colorFill)
									*(dstPtr - 1) = colorShadow;

								if (x < rect->right - 1 && *(dstPtr + 1) != colorFill)
									*(dstPtr + 1) = colorShadow;

								if (y > rect->top && *(dstPtr - dstPitch) != colorFill)
									*(dstPtr - dstPitch) = colorShadow;

								if (y < rect->bottom - 1 && *(dstPtr + dstPitch) != colorFill)
									*(dstPtr + dstPitch) = colorShadow;
							}
						}

						++x;

						if (!--mask)
						{
							mask = 8;
							srcVal = *(++srcPtr);
						}
						else
							srcVal <<= 1;

						++dstPtr;
					} while (--width);

					++y;
					src += srcPitch;
					dst += dstPitch;
				} while (--height);
			}
		}
	}

	VOID __stdcall DrawLineHorizontal(DWORD* data, SIZE* sizePitch, POINT pt, LONG width, DWORD colorFill)
	{
		POINT shift = { 0, 0 };
		SIZE size = { width, 1 };
		RECT clipper = { 0, 0, sizePitch->cx, sizePitch->cy };

		if (Clip(&shift, &pt, &size, &clipper))
		{
			colorFill = Convert565toRGB(colorFill);

			DWORD* dst = (DWORD*)data + pt.y * sizePitch->cx + pt.x;
			do
				*dst++ = colorFill;
			while (--width);
		}
	}

	VOID __stdcall DrawLineVertical(DWORD* data, SIZE* sizePitch, POINT pt, LONG height, DWORD colorFill)
	{
		POINT shift = { 0, 0 };
		SIZE size = { 1, height };
		RECT clipper = { 0, 0, sizePitch->cx, sizePitch->cy };

		if (Clip(&shift, &pt, &size, &clipper))
		{
			colorFill = Convert565toRGB(colorFill);

			DWORD* dst = (DWORD*)data + pt.y * sizePitch->cx + pt.x;
			do
			{
				*dst = colorFill;
				dst += sizePitch->cx;
			} while (--height);
		}
	}

	VOID __stdcall DrawMinimapGround(DWORD* thisObj, LONG left, LONG top, BlitObject* obj)
	{
		if (left > 0 && left < obj->rect.right && top > 0 && top < obj->rect.bottom)
		{
			SIZE* size = (*(SIZE * (__thiscall**)(DWORD*))(*thisObj + 4))(thisObj);
			LONG pitch = (*(LONG(__thiscall**)(DWORD*))(*thisObj + 12))(thisObj);
			VOID* data = (*(VOID * (__thiscall**)(DWORD*))(*thisObj + 8))(thisObj);

			LONG shiftX = left % size->cx;
			if (shiftX >= size->cx - 4)
				shiftX -= size->cx - 4;

			LONG shiftY = top % size->cy;
			if (shiftY >= size->cy - 2)
				shiftY -= size->cy - 2;

			LONG srcPitch = pitch >> 1;
			DWORD* srcData = (DWORD*)data + shiftY * srcPitch + shiftX;

			LONG dstPitch = obj->pitch >> 1;
			DWORD* dstData = (DWORD*)obj->data + top * dstPitch + left;

			DWORD y = 1;

			if (config.renderer == RendererGDI)
			{
				do
				{
					DWORD* src = srcData;
					DWORD* dst = dstData;

					DWORD x = 3;
					do
					{
						if ((0x4E >> ((y << 2) + x)) & 1)
							*dst = *src;

						++src;
						++dst;
					} while (x--);

					srcData += srcPitch;
					dstData += dstPitch;
				} while (y--);
			}
			else
			{
				do
				{
					DWORD* src = srcData;
					DWORD* dst = dstData;

					DWORD x = 3;
					do
					{
						if ((0x4E >> ((y << 2) + x)) & 1)
							*dst = _byteswap_ulong(_rotl(*src, 8));

						++src;
						++dst;
					} while (x--);

					srcData += srcPitch;
					dstData += dstPitch;
				} while (y--);
			}
		}
	}

	VOID __stdcall DrawCastleBuildings(DWORD* thisObj, BlitObject* obj)
	{
		obj->color = 0xF81F;
		FillColor(obj, NULL, obj->color, &obj->rect);

		LONG width = thisObj[12];
		LONG height = thisObj[13];
		if (height > 0 && width > 0)
		{
			BOOL isBlend;
			DWORD blend;

			switch (thisObj[14])
			{
			case 1: // selected line
				isBlend = TRUE;
				blend = config.renderer == RendererGDI ? 0x000000C4 : 0x00C40000;
				break;

			case 2: // unavailable yet
				isBlend = TRUE;
				blend = config.renderer == RendererGDI ? 0x00FF0000 : 0x000000FF;
				break;

			case 3: // other line
				isBlend = TRUE;
				blend = 0x00000000;
				break;

			default:
				isBlend = FALSE;
				break;
			}

			LONG srcPitch = width;
			LONG dstPitch = obj->pitch >> 1;

			DWORD* srcData = *((DWORD**)thisObj[11] + 1);
			DWORD* dstData = (DWORD*)obj->data;

			for (LONG h = height; h; --h)
			{
				DWORD* src = srcData;
				DWORD* dst = dstData;

				for (LONG w = width; w; --w)
				{
					DWORD pix = *src;
					if ((pix & COLORKEY_AND) != COLORKEY_CHECK)
					{
						if (isBlend)
							pix = Blend(pix, blend, 128);

						*dst = pix;
					}

					++src;
					++dst;
				}

				srcData += srcPitch;
				dstData += dstPitch;
			}
		}

		*(BYTE*)&thisObj[9] = 0;
	}

	VOID __stdcall DrawFaces(VOID* dstData, LONG dstPitch, VOID* srcData, LONG srcPitch, LONG top, LONG bottom, LONG width, BYTE isMirror, BYTE k, DWORD minIdx, PixObject* pixData_1, PixObject* pixData_2, VOID* mskData, LONG mskPitch)
	{
		DWORD* source = (DWORD*)srcData + top * srcPitch;
		DWORD* mask = (DWORD*)mskData + top * mskPitch;
		DWORD* destination = (DWORD*)dstData + top * dstPitch + (isMirror ? width - 1 : 0);

		DWORD idx = 0;

		if (config.renderer == RendererGDI)
		{
			for (LONG h = bottom - top; h; --h)
			{
				DWORD* src = source;
				DWORD* msk = mask;
				DWORD* dst = destination;

				for (LONG w = width; w; --w)
				{
					DWORD pix = *src;
					if (mskData || pixData_1->exists)
						pix = Blend(pix, mskData ? *msk : _byteswap_ulong(_rotl(pixData_1->color, 8)), k);

					if (idx >= minIdx && pixData_2->exists) // color
						pix = Blend(pix, _byteswap_ulong(_rotl(pixData_2->color, 8)), k);

					*dst = pix;

					++src;
					++msk;

					if (isMirror)
						--dst;
					else
						++dst;
				}

				source += srcPitch;
				mask += mskPitch;
				destination += dstPitch;

				++idx;
			}
		}
		else
		{
			for (LONG h = bottom - top; h; --h)
			{
				DWORD* src = source;
				DWORD* msk = mask;
				DWORD* dst = destination;

				for (LONG w = width; w; --w)
				{
					DWORD pix = *src;
					if (mskData || pixData_1->exists)
						pix = Blend(pix, mskData ? *msk : pixData_1->color, k);

					if (idx >= minIdx && pixData_2->exists) // color
						pix = Blend(pix, pixData_2->color, k);

					*dst = pix;

					++src;
					++msk;

					if (isMirror)
						--dst;
					else
						++dst;
				}

				source += srcPitch;
				mask += mskPitch;
				destination += dstPitch;

				++idx;
			}
		}
	}

	VOID __stdcall DrawLine(BlitObject* obj, POINT* loc, DWORD count, DWORD color)
	{
		DWORD pitch = obj->pitch >> 1;
		color = Convert565toRGB(color);

		DWORD* data = (DWORD*)obj->data + loc->y * pitch + loc->x;
		for (; count; --count)
			*data++ = color;
	}

	DWORD back_005383AA;
	VOID __declspec(naked) hook_005383A5()
	{
		__asm {
			mov ecx, [ebp-0x1C]
			call Convert565toRGB
			mov [ebp-0x1C], eax

			mov eax, [ebp-0x14]
			test eax, eax

			jmp back_005383AA
		}
	}

	DWORD back_00538413;
	VOID __declspec(naked) hook_005383F7()
	{
		__asm {
			shl ebx, 0x1
			mov ecx, eax
			mov eax, [ecx+0x4]
			imul eax, ebx
			add esi, eax
			mov eax, [ecx]
			mov ecx, [ebp-0x1C]
			mov [eax*0x4+esi], ecx
			inc edi

			jmp back_00538413
		}
	}

#pragma endregion

#pragma region HD
	VOID __stdcall SetResolution(SIZE* size)
	{
		size->cx = config.mode->width;
		size->cy = config.mode->height;
	}

	INT __stdcall GetSystemMetricsHook(INT nIndex)
	{
		switch (nIndex)
		{
		case SM_CXSCREEN:
			return config.mode->width;
		case SM_CYSCREEN:
			return config.mode->height;
		case SM_SWAPBUTTON:
			return FALSE;
		default:
			return GetSystemMetrics(nIndex);
		}
	}

	DWORD back_00611CEF;
	VOID __declspec(naked) hook_00611C8B()
	{
		__asm
		{
			mov eax, [esi]
			add eax, 0x198
			push eax
			push back_00611CEF
			jmp SetResolution
		}
	}

	DWORD battleAddress;
	VOID __stdcall CheckBordersV2(DWORD* object, BOOL isborder)
	{
		config.borders.active = isborder & 1;
		if (*(object + 2) != 0xFFFFFFFF)
			config.battle.active = *object == battleAddress;
	}

	VOID __declspec(naked) hook_00538FEB()
	{
		__asm {
			call [eax+0x24]

			push eax
			push edi
			call CheckBordersV2

			xor eax, eax
			retn
		}
	}

	DWORD back_00489136;
	VOID __declspec(naked) hook_00489124()
	{
		__asm {
			cmp [esi+0x68], ebx
			je lbl_success
			cmp config.borders.active, ebx
			je lbl_back

			lbl_success : mov eax, [ecx]
						  add esi, 0x64

						  mov edx, [esi+0x4]
						  cmp config.borders.active, ebx
						  je lbl_continue
						  shr edx, 0x1

						  lbl_continue : push edx
										 mov edx, [esi]
										 cmp config.borders.active, ebx
										 je lbl_continue2
										 shr edx, 0x1

										 lbl_continue2 : push edx
														mov esi, esp
														push ebx
														push ebx
														push ebx
														push esi
														push edi
														call [eax+0x14]

														add esp, 0x8

														lbl_back : jmp back_00489136
		}
	}
#pragma endregion

#pragma region Game Speed
	DWORD* animSpeed;
	DWORD* mapSpeed;

	TimeScale gameSpeed;
	DWORD GetTimeSpeed(TimeScale* time, DOUBLE scale)
	{
		if (time->scale != scale)
		{
			time->scale = scale;

			time->lastReal = time->real;
			time->lastVirt = time->virt;
		}

		time->real = timeGetTime();
		time->virt = time->lastVirt + DWORD(time->scale * (time->real - time->lastReal));

		return time->virt;
	}

	DWORD __stdcall timeGetTimeHook()
	{
		return GetTimeSpeed(&gameSpeed, config.speed.enabled ? config.speed.value : 1.0);
	}

	DWORD __stdcall GetDoubleClickTimeHook()
	{
		return config.speed.hooked || !config.speed.enabled ? GetDoubleClickTime() : DWORD((FLOAT)GetDoubleClickTime() * config.speed.value);
	}

	VOID __stdcall SetAnimSpeed()
	{
		const DOUBLE value = 1000.0 / 15.0;
		if (animSpeed)
			*animSpeed = config.speed.enabled ? DWORD(value / config.speed.value) : 66;
	}

	VOID __stdcall SetMapSpeed()
	{
		const DOUBLE value = 1000.0 / 30.0;
		if (mapSpeed)
			*mapSpeed = config.speed.enabled ? DWORD(value / config.speed.value) : 33;
	}

	VOID SetGameSpeed()
	{
		SetAnimSpeed();
		SetMapSpeed();
	}

	VOID __declspec(naked) hook_004E1FA7()
	{
		__asm
		{
			lea eax, [esi+0x98]
			mov animSpeed, eax
			jmp SetAnimSpeed
		}
	}

	VOID __declspec(naked) hook_00519FF1()
	{
		__asm
		{
			push ecx

			lea eax, [esi+0x34]
			mov animSpeed, eax
			call SetAnimSpeed

			pop ecx
			retn
		}
	}

	VOID __declspec(naked) hook_0051A0A9()
	{
		__asm
		{
			push ecx

			lea eax, [esi+0x34]
			mov mapSpeed, eax
			call SetMapSpeed

			pop ecx
			retn
		}
	}

	DWORD __fastcall GetTimeHook(DWORD** _this)
	{
		if (_this[1])
		{
			_this = (DWORD**)_this[1][1];
			if (_this)
			{
				DWORD func = _this[0][14];
				return ((DWORD(__thiscall*)(DWORD**))func)(_this);
			}
		}

		return 0;
	}

#pragma endregion

#pragma region Scroll and Double Click
#define EASY_IN 100
#define EASY_OUT 200

	VOID __fastcall GetScrollOffset(POINT* offset)
	{
		DOUBLE off = config.scroll.value * (1.0 - 0.005 * config.scroll.speed);
		offset->y = (LONG)MathRound(off);
		offset->x = (LONG)MathRound(off * 2.0);
	}

	VOID __declspec(naked) hook_004E0323()
	{
		__asm
		{
			pop eax

			push eax
			push eax
			mov ecx, esp
			push esi

			push eax
			jmp GetScrollOffset
		}
	}

	VOID __declspec(naked) hook_0053D185()
	{
		__asm {
			pop ecx

			push eax
			push eax

			push ecx
			push eax

			lea ecx, [esp+0x8]
			call GetScrollOffset

			pop eax
			mov edi, [eax]
			
			retn
		}
	}

	DWORD __fastcall GetScrollTime(DWORD time)
	{
		const DOUBLE value = 1000.0 / 60.0;

		config.scroll.speed = time;
		return !config.speed.hooked && config.speed.enabled ? DWORD(value * config.speed.value) : 16;
	}

	DWORD __fastcall PreCheckScroll(ScrollDirection dir)
	{
		if (!config.scroll.edge.active)
			return ScrollCenter;

		if (dir != ScrollCenter)
		{
			config.scroll.dir = dir;
			if (config.scroll.state != ScrollStarted)
				config.scroll.state = ScrollStarting;
			return dir;
		}

		if (config.scroll.state != ScrollNone)
		{
			if (config.scroll.state == ScrollStarted)
				config.scroll.state = ScrollEnding;
			return config.scroll.dir;
		}

		return ScrollCenter;
	}

	VOID __declspec(naked) hook_004E0AA8()
	{
		__asm {
			mov eax, [ecx]
			mov ecx, [eax+0x44]
			call GetScrollTime
			push eax

			mov ecx, ebx
			call PreCheckScroll
			mov ebx, eax

			pop eax
			retn
		}
	}

	VOID __declspec(naked) hook_0053D94B()
	{
		__asm {
			mov eax, [ecx]
			mov ecx, [eax+0x40]
			call GetScrollTime
			push eax

			mov ecx, edi
			call PreCheckScroll
			mov edi, eax

			pop eax
			retn
		}
	}

	DWORD __fastcall CheckScroll(ScrollDirection dir, DWORD time)
	{
		if (dir != ScrollCenter)
		{
			switch (config.scroll.state)
			{
			case ScrollStarting: {
				config.scroll.state = ScrollStarted;
				config.scroll.time = time;
			}
			case ScrollStarted: {
				DWORD easy = DWORD(config.scroll.easy.in * EASY_IN);
				DWORD diff = min(EASY_IN, easy + time - config.scroll.time);
				config.scroll.easy.out = (FLOAT)diff / EASY_IN;
				if (diff)
				{
					config.scroll.value = (FLOAT)MathSinus(M_PI * 0.5 * diff / EASY_IN) * config.scroll.multi;
					return dir;
				}
				break;
			}
			case ScrollEnding: {
				config.scroll.state = ScrollEnded;
				config.scroll.time = time;
			}
			case ScrollEnded: {
				DWORD easy = DWORD(config.scroll.easy.out * EASY_OUT);
				DWORD diff = easy - min(easy, time - config.scroll.time);
				config.scroll.easy.in = (FLOAT)diff / EASY_OUT;
				if (diff)
				{
					config.scroll.value = (FLOAT)MathSinus(M_PI * 0.5 * diff / EASY_OUT) * config.scroll.multi;
					return dir;
				}
				config.scroll.state = ScrollNone;
				break;
			}
			default:
				break;
			}
		}

		return ScrollCenter;
	}

	VOID __declspec(naked) hook_004E0AF0()
	{
		__asm
		{
			push ecx

			mov edx, edi
			mov ecx, ebx
			call CheckScroll
			mov ebx, eax

			pop ecx
			xor eax, eax
			cmp ebx, ScrollCenter
			retn
		}
	}

	VOID __declspec(naked) hook_0053D98C()
	{
		__asm
		{
			mov edx, [ebp-0x10]
			mov ecx, edi
			call CheckScroll
			mov edi, eax

			xor eax, eax
			cmp edi, ScrollCenter
			retn
		}
	}

	VOID __fastcall CheckKeyScroll(DWORD* obj, DWORD /*edx*/, ScrollDirection dir)
	{
		if (config.scroll.isWheel)
		{
			config.scroll.isWheel = FALSE;
			return;
		}

		switch (dir)
		{
		case ScrollTop:
			if (GetAsyncKeyState(VK_LEFT) & 0x8000)
				dir = ScrollTopLeft;
			else if (GetAsyncKeyState(VK_RIGHT) & 0x8000)
				dir = ScrollTopRight;
			break;
		case ScrollRight:
			if (GetAsyncKeyState(VK_UP) & 0x8000)
				dir = ScrollTopRight;
			else if (GetAsyncKeyState(VK_DOWN) & 0x8000)
				dir = ScrollBottomRight;
			break;
		case ScrollBottom:
			if (GetAsyncKeyState(VK_LEFT) & 0x8000)
				dir = ScrollBottomLeft;
			else if (GetAsyncKeyState(VK_RIGHT) & 0x8000)
				dir = ScrollBottomRight;
			break;
		case ScrollLeft:
			if (GetAsyncKeyState(VK_UP) & 0x8000)
				dir = ScrollTopLeft;
			else if (GetAsyncKeyState(VK_DOWN) & 0x8000)
				dir = ScrollBottomLeft;
			break;
		default:
			break;
		}

		config.scroll.dir = dir;
		config.scroll.easy.out = 1.0f;
		config.scroll.state = ScrollEnding;

		DWORD* func = (DWORD*)(*obj + (config.type.sacred ? 128 : 144));
		((VOID(__thiscall*)(DWORD*, ScrollDirection)) * func)(obj, dir);
	}

	VOID __declspec(naked) hook_0053D7EE()
	{
		__asm
		{
			mov ecx, esi
			jmp CheckKeyScroll
		}
	}

	VOID __declspec(naked) hook_0053A73D()
	{
		__asm
		{
			push eax
			call GetDoubleClickTimeHook
			mov ecx, eax
			pop eax
			retn
		}
	}
#pragma endregion

#pragma region CPU patch
	BOOL __stdcall PeekMessageHook(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg)
	{
		if (PeekMessage(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax, wRemoveMsg))
			return TRUE;

		if (config.coldCPU && !config.ai.thinking)
			Sleep(1);

		return FALSE;
	}

	BOOL __stdcall SetThreadPriorityHook(HANDLE hThread, INT nPriority)
	{
		return TRUE;
	}

	DWORD waitAddress;
	VOID __stdcall DrawDialog(DWORD* lpOld, DWORD dlgNew)
	{
		DWORD dlgOld = *lpOld;
		if (dlgOld != dlgNew)
		{
			*lpOld = dlgNew;

			if (dlgOld)
				((VOID(__thiscall*)(DWORD, BOOL))(**(DWORD**)dlgOld))(dlgOld, TRUE);

			config.ai.waiting = dlgNew && *(DWORD*)dlgNew == waitAddress;
		}
	}

	VOID __declspec(naked) hook_004F1464()
	{
		__asm {
			mov eax, [esp+0x4]
			push eax
			push ecx
			call DrawDialog
			retn 0x4
		}
	}

	DWORD waitObject;
	DWORD sub_005AE161;
	DWORD sub_006ACED2;
	VOID __declspec(naked) hook_005AE161()
	{
		__asm {
			mov eax, [esp+0x4]
			mov ecx, [eax]
			push ecx

			push eax
			mov eax, sub_006ACED2
			call sub_005AE161;

			pop ecx
			cmp ecx, 0x1
			jne non_wait

			mov waitObject, eax

			non_wait:
			retn 0x4
		}
	}

	DWORD sub_0052EE9E;
	VOID __declspec(naked) hook_0053C095()
	{
		__asm {
			cmp ecx, waitObject
			jne lbl_non
			mov config.ai.waiting, 0x1
			jmp lbl_cont
			
			lbl_non:
			mov config.ai.waiting, 0x0

			lbl_cont:
			mov eax, [esp+0x8]
			push eax
			mov eax, [esp+0x8]
			push eax
			call sub_0052EE9E

			retn 0x8
		}
	}
#pragma endregion

#pragma region Widescreen Battle
	DWORD sub_00629FAA;
	VOID __declspec(naked) hook_0062891A()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide
			retn 0x4

			non_wide:
			lea ecx, [ebp-0x1C]
			push ecx
			mov ecx, [ebp-0x30]
			call sub_00629FAA
			retn 0x4
		}
	}

	DWORD back_0062F52A;
	VOID __declspec(naked) hook_0062F524()
	{
		__asm {
 			mov eax, config.battle.wide
			test eax, eax
			jz non_wide
			retn

			non_wide:
			push ebp
			mov ebp, esp
			sub esp, 0x10
			jmp back_0062F52A
		}
	}

	DWORD back_00625688;
	VOID __declspec(naked) hook_00625683()
	{
		__asm {
 			mov eax, config.battle.wide
			test eax, eax
			jz non_wide
			retn 0x4

			non_wide:
			push ebp
			mov ebp, esp
			push ecx
			push esi
			jmp back_00625688
		}
	}

	VOID __declspec(naked) hook_00624F2F()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			inc edx
			retn

			non_wide:
			mov dl, [ecx+0x0B55]
			retn
		}
	}

	VOID __declspec(naked) hook_0062ED48()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			mov dl, [ecx+0x14F7]
			retn

			non_wide:
			mov dl, [ecx+0x14F6]
			retn
		}
	}

	VOID __declspec(naked) hook_0062521D()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide
			
			mov ecx, [ecx+0x1C]
			mov eax, [ecx+0x9E4]
			mov eax, [eax+0x8]
			mov [eax+0x50], 0x1
			mov eax, [ecx+0x9E8]
			mov eax, [eax+0x8]
			mov [eax+0x50], 0x1
			retn

			non_wide:
			push ebp
			mov ebp, esp
			sub esp, 0x10
			jmp back_0062F52A
		}
	}

	VOID __declspec(naked) hook_0062DAA8()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide
			
			mov ecx, [ecx+0x1C]
			mov eax, [ecx+0x1384]
			mov eax, [eax+0x8]
			mov [eax+0x50], 0x1
			mov eax, [ecx+0x1388]
			mov eax, [eax+0x8]
			mov [eax+0x50], 0x1
			retn

			non_wide:
			push ebp
			mov ebp, esp
			sub esp, 0x10
			jmp back_0062F52A
		}
	}

	DWORD sub_00643E80;
	VOID __declspec(naked) hook_0062F5B8()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			JZ non_wide
			retn

			non_wide:
			jmp sub_00643E80
		}
	}

	VOID __declspec(naked) hook_00625EAE()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			pop eax
			add ecx, 0x30
			push ecx
			jz non_wide

			push 0x1
			push 0x1
			push eax
			retn

			non_wide:
			push 0x1
			push 0x0
			push eax
			retn
		}
	}

	VOID __declspec(naked) hook_00625EFD()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			add ecx, 0x9F8
			retn

			non_wide:
			add ecx, 0x9E4
			retn
		}
	}

	VOID __declspec(naked) hook_0062635D()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			pop eax
			add edx, 0x30
			push edx
			jz non_wide

			push 0x1
			push 0x0
			push eax
			retn

			non_wide:
			push 0x1
			push 0x1
			push eax
			retn
		}
	}

	VOID __declspec(naked) hook_006263AC()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			add ecx, 0x9E4
			retn

			non_wide:
			add ecx, 0x9F8
			retn
		}
	}

	VOID __declspec(naked) hook_0062E7FB()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			pop eax
			add ecx, 0x30
			push ecx
			jz non_wide

			push 0x0
			push eax
			retn

			non_wide:
			push 0x1
			push eax
			retn
		}
	}

	VOID __declspec(naked) hook_0062E848()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			add ecx, 0x1398
			retn

			non_wide:
			add ecx, 0x1384
			retn
		}
	}

	VOID __declspec(naked) hook_0062ECA9()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			pop eax
			add edx, 0x30
			push edx
			jz non_wide

			push 0x1
			push eax
			retn

			non_wide:
			push 0x0
			push eax
			retn
		}
	}

	VOID __declspec(naked) hook_0062ECFC()
	{
		__asm {
			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			add ecx, 0x1384
			retn

			non_wide:
			add ecx, 0x1398
			retn
		}
	}

	const CHAR* const dlgNames[2] = {
		"DLG_BATTLE_A",
		"DLG_BATTLE_B"
	};

	VOID __stdcall CalcWideBattle()
	{
		if (config.wide.allowed)
		{
			config.battle.zoomable = TRUE;
			config.battle.wide = config.zoom.enabled ? config.zoom.size.width >= WIDE_WIDTH : TRUE;
		}
		else
			config.battle.wide = config.battle.zoomable = FALSE;
	}

	VOID __declspec(naked) hook_006244CA()
	{
		__asm {
			call CalcWideBattle

			lea ecx, dlgNames

			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			add ecx, 0x4
			
			non_wide:
			mov ecx, [ecx]
			retn
		}
	}

	VOID __declspec(naked) hook_0062476C()
	{
		__asm {
			lea edx, dlgNames

			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			add edx, 0x4
			
			non_wide:
			mov edx, [edx]
			retn
		}
	}

	const ImageIndices battleIndices = {
		990, 200,
		&battleIndices.indices,
		11,

		0, 96, 346, 0, 279, 104,
		279, 96, 594, 0, 20, 104,
		299, 96, 550, 0, 180, 104,

		511, 96, 346, 104, 180, 104,
		691, 96, 458, 104, 20, 104,
		711, 96, 451, 104, 279, 104,

		0, 64, 346, 208, 148, 32,
		843, 64, 346, 240, 147, 32,
		0, 34, 346, 272, 123, 30,
		869, 35, 346, 302, 121, 29,

		479, 94, 346, 331, 32, 106
	};

	VOID __fastcall ChangeBattleIndices(DWORD* object)
	{
		((DWORD*)object[1])[7] = (DWORD)&battleIndices;
	}

	DWORD sub_00625387;
	VOID __declspec(naked) hook_00625387()
	{
		__asm {
			mov edx, config.battle.wide
			test edx, edx
			jz non_wide

			push ecx
			mov ecx, eax
			call ChangeBattleIndices
			pop ecx

			non_wide:
			jmp sub_00625387
		}
	}

	VOID __declspec(naked) hook_0063E6B8()
	{
		__asm {
			push [eax]
			sub esi, [eax]

			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			sar esi, 0x1
			pop eax
			mov [ebp-0x8], esi
			retn

			non_wide:
			pop eax
			sub eax, 950
			shr eax, 0x1

			MOV ECX, [EBP+0x10]
			test cl, cl
			jnz mirror

			xor esi, esi
			sub esi, eax
			mov [ebp-0x8], esi
			retn

			mirror:
			add esi, eax
			mov [ebp-0x8], esi
			retn
		}
	}

	BOOL GetStr(CHAR* str, INT num, FILE* stream)
	{
		static struct {
			Stream stream;
			BOOL loaded;
			BOOL unloaded;
		} dlgOptions;

		if (!dlgOptions.loaded)
		{
			dlgOptions.loaded = TRUE;
			if (!Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_BATTLE_B), &dlgOptions.stream))
				dlgOptions.unloaded = TRUE;
		}

		if (!dlgOptions.unloaded)
		{
			Stream* stream = &dlgOptions.stream;

			CHAR* p = (CHAR*)stream->data;
			DWORD size = stream->size - stream->position;

			do
			{
				if (!size)
				{
					p = NULL;
					break;
				}

				if (*p == '\n' || *p == '\0')
					break;

				++p;
				--size;
			} while (TRUE);

			if (p && p - (CHAR*)stream->data <= num - 1)
			{
				DWORD length = p - (CHAR*)stream->data;
				MemoryCopy(str, stream->data, length);
				stream->position += length + 1;
				stream->data += length + 1;
				str[length] = NULL;
			}
			else
			{
				DWORD length = num - 1;
				MemoryCopy(str, stream->data, length);
				stream->position += length;
				stream->data += length;
				str[length] = NULL;
			}

			if (stream->position == stream->size)
				dlgOptions.unloaded = TRUE;

			return FALSE;
		}

		return TRUE;
	}

	CHAR* __cdecl FileGetStrHook(CHAR* str, INT num, FILE* stream)
	{
		return GetStr(str, num, stream) ? FileGetStr(str, num, stream) : str;
	}

	DWORD sub_fgets;
	CHAR* __stdcall SteamFileGetStrHook(CHAR* str, INT num, FILE* stream)
	{
		return GetStr(str, num, stream) ? ((CHAR * (__stdcall*)(CHAR*, INT, FILE*)) sub_fgets)(str, num, stream) : str;
	}

	DWORD rectListShift;
	VOID __declspec(naked) hook_006307E8()
	{
		__asm {
			xor eax, eax
			mov [ebp-0x70], eax

			mov eax, config.battle.wide
			test eax, eax
			jz non_wide

			mov eax, [ebp-0x108]
			mov ecx, [eax+0x1C]
			add ecx, rectListShift
			mov [ebp-0x24], ecx

			non_wide:
			retn
		}
	}
#pragma endregion

#pragma region Mirror Battle
	BOOL isMirror;
	DWORD sub_005A9A1E;

	DWORD __fastcall GetBattleBgNext(DWORD** thisObj, DWORD /*edx*/, CHAR* name)
	{
		/*DWORD nl = StrLength(name);
		const CHAR* nname = "WATER_0";
		if (!StrCompare(&name[nl - StrLength("BG")], "BG"))
		{
			StrCopy(name, nname);
			StrCat(name, "_BG");
		}
		else if (!StrCompare(&name[nl - StrLength("FG")], "FG"))
		{
			StrCopy(name, nname);
			StrCat(name, "_FG");
		}
		else
		{
			StrCopy(name, nname);
			StrCat(name, "_SHADOW");
		}*/

		return ((DWORD(__stdcall*)(DWORD, CHAR*, BOOL, BOOL, DWORD))sub_005A9A1E)(thisObj[0][10], name, isMirror, TRUE /*isRandom*/, **thisObj);
	}

	DWORD __fastcall GetBattleBgFirts(DWORD** thisObj, DWORD /*edx*/, CHAR* name)
	{
		isMirror = config.battle.mirror ? (Random() & 1u) : FALSE;
		return GetBattleBgNext(thisObj, NULL, name);
	}
#pragma endregion

#pragma region Custom Package
	DWORD sub_LoadImgPackage;
	DWORD __stdcall LoadImgPackage(DWORD** store, CHAR* dir, CHAR* filename, DWORD unknown)
	{
		store[24] = NULL;
		if (((DWORD(__stdcall*)(DWORD**, CHAR*, CHAR*, DWORD))sub_LoadImgPackage)(store + 24, dir, "Wrapper.ff", unknown))
			config.packages.wrapper = store[24];

		store[25] = NULL;
		if (((DWORD(__stdcall*)(DWORD**, CHAR*, CHAR*, DWORD))sub_LoadImgPackage)(store + 25, dir, "IsoClouds.ff", unknown))
			config.packages.clouds = store[25];

		return ((DWORD(__stdcall*)(DWORD**, CHAR*, CHAR*, DWORD))sub_LoadImgPackage)(store, dir, filename, unknown);
	}

	DWORD sub_0052A14E;
	BOOL __fastcall LoadPackageIndex(DWORD** pakObj, DWORD /*edx*/, CHAR* name, DWORD a3, DWORD a4)
	{
		if (config.packages.wrapper)
		{
			DWORD* pak = (DWORD*)*config.packages.wrapper;
			if ((*(BOOL(__thiscall*)(DWORD, CHAR*, DWORD, DWORD, DWORD))sub_0052A14E)(pak[3], name, a3, a4, pak[5]))
				return TRUE;
		}

		BOOL res = (*(BOOL(__thiscall*)(DWORD, CHAR*, DWORD, DWORD, DWORD))sub_0052A14E)(pakObj[0][3], name, a3, a4, pakObj[0][5]);

		if (!res && config.packages.clouds)
		{
			DWORD* pak = (DWORD*)*config.packages.clouds;
			if ((*(BOOL(__thiscall*)(DWORD, CHAR*, DWORD, DWORD, DWORD))sub_0052A14E)(pak[3], name, a3, a4, pak[5]))
				return TRUE;
		}

		return res;
	}

	DWORD* __fastcall CheckCloudPackage(DWORD* pak, CHAR* name)
	{
		return !config.packages.clouds || StrCompareNum(name, "CLOUD", 5) ? pak : config.packages.clouds;
	}

	DWORD sub_0051F87C;
	VOID __declspec(naked) hook_005C2789()
	{
		__asm {
			mov edx, [ebp+0x10]
			call CheckCloudPackage
			mov ecx, eax
			jmp sub_0051F87C
		}
	}

	const FLOAT clouds_count = 15.0f;
	const FLOAT clouds_factor = 7.0f / 3.0f;

	VOID __declspec(naked) hook_005B8F00()
	{
		__asm {
			cmp config.packages.clouds, 0
			je lbl_classic
			fmul clouds_factor

			lbl_classic:
			fmul config.cloudsFactor;
			fmul clouds_count
			retn
		}
	}

	LONG RandomPoor(LONG max)
	{
		return max ? (Random() % max) : 0;
	}

	VOID __fastcall InitClouds(CloudObject* obj, SIZE* sizek)
	{
		if (obj->list && obj->count > 0)
		{
			SIZE mode = { *(LONG*)&config.mode->width, 128 };

			obj->mapSize = { sizek->cx + 1, sizek->cy + 1 };
			obj->boundsSize = { obj->mapSize.cx * 64 + mode.cx, obj->mapSize.cy * 32 + mode.cy };

			CloudItem* cloud = obj->list;
			INT count = obj->count;

			LONG x = 0;
			LONG y = 0;
			do
			{
				cloud->flags = NULL;

				cloud->center.x = x;
				cloud->center.y = y;

				if (++y == obj->mapSize.cy)
				{
					y = 0;
					if (++x == obj->mapSize.cx)
						x = 0;
				}

				cloud->offset.x = RandomPoor(obj->boundsSize.cx) - (obj->mapSize.cy - cloud->center.y + cloud->center.x) * 32 - mode.cx / 2;
				cloud->offset.y = RandomPoor(obj->boundsSize.cy) - (cloud->center.y + cloud->center.x) * 16 - mode.cy / 2;
				cloud->speed = RandomPoor(5) + 1;

				++cloud;
			} while (--count);
		}
	}

	VOID __declspec(naked) hook_005B8F53()
	{
		__asm {
			lea edx, [ebp-0x2C]
			call InitClouds

			mov ecx, [ebp-0xC]
			mov eax,esi
			pop edi
			pop esi
			mov dword ptr fs:[0], ecx
			pop ebx
			leave
			retn
		}
	}

	VOID __fastcall CheckCloud(CloudItem* cloud, CloudObject* obj)
	{
		SIZE mode = { *(LONG*)&config.mode->width, 128 };
		LONG dist = (obj->mapSize.cy - cloud->center.y + cloud->center.x) * 32 + mode.cx / 2;

		if (cloud->offset.x >= (obj->boundsSize.cx) - dist)
		{
			cloud->offset.x = -dist;
			cloud->offset.y = RandomPoor(obj->boundsSize.cy) - (cloud->center.y + cloud->center.x) * 16 - mode.cy / 2;
		}

		if (cloud->hasShadow && cloud->speed > 3)
			cloud->speed = RandomPoor(3) + 1;
	}

	DWORD back_005B9214;
	VOID __declspec(naked) hook_005B91BB()
	{
		__asm {
			mov edx, [edi+0x4]
			mov ecx, esi
			push back_005B9214
			jmp CheckCloud
		}
	}
#pragma endregion

#pragma region Debug window and messages
	VOID __fastcall CalcDebugPosition(POINT* point)
	{
		if (Config::IsZoomed())
		{
			point->x = (config.mode->width - config.zoom.size.width) >> 1;
			point->y = (config.mode->height - config.zoom.size.height) >> 1;
		}
		else
		{
			point->x = 0;
			point->y = 0;
		}
	}

	VOID __declspec(naked) hook_0052EAAE()
	{
		__asm {
			push eax

			lea ecx, [ebp-0x8]
			call CalcDebugPosition

			pop eax
			xor ecx, ecx

			retn
		}
	}

	VOID __fastcall CalcMessage(DWORD* object, POINT* point)
	{
		if (Config::IsZoomed())
		{
			POINT offset = {
				LONG((config.mode->width - config.zoom.size.width) >> 1),
				LONG((config.mode->height - config.zoom.size.height) >> 1)
			};

			point->x += offset.x;

			if (*(BYTE*)(object + 24))
				point->y += offset.y;
			else
				point->y -= offset.y;
		}
	}

	VOID __declspec(naked) hook_00484DD1()
	{
		__asm {
			push ecx

			mov edx, [esp+0xC]
			mov ecx, esi
			call CalcMessage
			
			pop ecx
			mov eax, [ecx]
			jmp dword ptr [eax+0x14]
		}
	}

	TimeScale msgScale;
	DWORD __stdcall MessageTimeout()
	{
		return GetTimeSpeed(&msgScale, config.msgTimeScale.value);
	}

	VOID __declspec(naked) hook_00484CD0()
	{
		__asm {
			push ecx

			call MessageTimeout
			
			pop ecx
			retn
		}
	}
#pragma endregion

#pragma region Map direction bit - mask Fix
	VOID __fastcall SetMapBitMask(BYTE* mask, POINT* p)
	{
		if (p->x >= 0 && p->y >= 0 && p->x < 144 && p->y < 144)
		{
			BYTE* address = &mask[18 * p->y] + (p->x >> 3);
			*address |= 1 << (p->x & 7);
		}
	}

	VOID __declspec(naked) hook_005C848D()
	{
		__asm
		{
			mov edx, [esp+0x4]
			call SetMapBitMask

			retn 0x4
		}
	}
#pragma endregion

#pragma region Locale
	// all these functions needed as msvcrt check int not byte
	// wrappers needed as parameter CHAR is not truncated
	INT __cdecl IsAlphaHook(BYTE ch)
	{
		return IsAlpha(ch);
	}

	INT __cdecl IsAlNumHook(BYTE ch)
	{
		return IsAlNum(ch);
	}

	INT __cdecl IsDigitHook(BYTE ch)
	{
		return IsDigit(ch);
	}

	INT __cdecl IsSpaceHook(BYTE ch)
	{
		return IsSpace(ch);
	}

	INT __cdecl IsPunctHook(BYTE ch)
	{
		return IsPunct(ch);
	}

	INT __cdecl IsCntrlHook(BYTE ch)
	{
		return IsCntrl(ch);
	}

	INT __cdecl IsUpperHook(BYTE ch)
	{
		return IsUpper(ch);
	}

	INT __cdecl ToUpperHook(BYTE ch)
	{
		return ToUpper(ch);
	}

	INT __cdecl ToLowerHook(BYTE ch)
	{
		return ToLower(ch);
	}

	const CHAR* __cdecl StrCharHook(const CHAR* str, BYTE ch)
	{
		return StrChar(str, ch);
	}

	const VOID* __cdecl MemoryCharHook(const VOID* block, BYTE ch, size_t length)
	{
		return MemoryChar(block, ch, length);
	}

	BOOL ConvertChars(const CHAR* srcData, UINT srcCP, CHAR* dstData, UINT dstCP)
	{
		static BYTE wideCharBuffer[4096];

		DWORD srcLength = StrLength(srcData);
		if (srcLength)
		{
			INT dstLength = MultiByteToWideChar(srcCP, NULL, srcData, srcLength, (LPWSTR)wideCharBuffer, sizeof(wideCharBuffer));
			return dstLength && WideCharToMultiByte(dstCP, NULL, (LPWSTR)wideCharBuffer, dstLength, dstData, srcLength, NULL, NULL);
		}
		else
		{
			*dstData = NULL;
			return TRUE;
		}
	}

	BOOL __stdcall OemToCharHook(LPCSTR pSrc, LPSTR pDst)
	{
		if (ConvertChars(pSrc, config.locales.current.oem, pDst, config.locales.current.ansi))
			return TRUE;

		return OemToChar(pSrc, pDst);
	}

	BOOL __stdcall CharToOemHook(LPCSTR pSrc, LPSTR pDst)
	{
		if (ConvertChars(pSrc, config.locales.current.ansi, pDst, config.locales.current.oem))
			return TRUE;

		return CharToOem(pSrc, pDst);
	}

	DWORD back_0048FAFB;
	VOID __declspec(naked) hook_0048FADD()
	{
		__asm {
			push eax
			call IsAlNumHook
			xor ecx, ecx 
			test eax, eax
			pop eax
			
			jnz lbl_ret
			inc ecx

			lbl_ret:
			cmp ecx, 0x0
			jmp back_0048FAFB
		}
	}

	DWORD back_00494B09;
	VOID __declspec(naked) hook_00494AED()
	{
		__asm {
			push eax
			call IsAlNumHook
			xor ecx, ecx 
			test eax, eax
			pop eax
			
			jnz lbl_ret
			inc ecx

			lbl_ret:
			cmp ecx, 0x0
			jmp back_00494B09
		}
	}
#pragma endregion

#pragma region Print text
	DWORD gameObject;
	DWORD sub_PrintText;
	VOID PrintText(CHAR* str)
	{
		if (gameObject)
			((VOID(__thiscall*)(DWORD, CHAR*))(sub_PrintText))(gameObject, str);
	}

	DWORD sub_GameObjectInit;
	VOID __declspec(naked) hook_00405A1A()
	{
		__asm
		{
			mov gameObject, ecx
			jmp sub_GameObjectInit
		}
	}

	DWORD sub_GameObjectDeInit;
	VOID __declspec(naked) hook_0048A93C()
	{
		__asm {
			mov eax, gameObject
			cmp ecx, eax
			jne lbl_return

			xor eax, eax
			mov gameObject, eax

			lbl_return: jmp sub_GameObjectDeInit
		}
	}
#pragma endregion

#pragma region AI list fix
	DWORD sub_GetType;
	DWORD sub_45287F;
	DWORD __stdcall sub_45287F_Hook(DWORD a1, DWORD a2, DWORD a3, DWORD type, DWORD a5, DWORD a6)
	{
		type = ((DWORD(__stdcall*)(DWORD))sub_GetType)(a5 - 4);
		return ((DWORD(__stdcall*)(DWORD, DWORD, DWORD, DWORD, DWORD, DWORD))sub_45287F)(a1, a2, a3, type, a5, a6);
	}
#pragma endregion

#pragma region Main interlock fix
	VOID __declspec(naked) InterlockHook()
	{
		__asm {
			push ecx
			mov eax, [esp+0x8]
			push eax
			call sub_EndLock
			pop ecx
			mov eax, [ecx]
			test eax, eax
			jz lbl_retn
			mov [eax], 0x00FFFFFF
			lbl_retn: retn 0x4
		}
	}
#pragma endregion

#pragma region Summoner fix
	DWORD sub_005E9984;
	VOID __declspec(naked) hook_0062682E()
	{
		__asm {
			test ecx, ecx
			jz lbl_exit
			jmp sub_005E9984

			lbl_exit:
			retn 0x4
		}
	}
#pragma endregion

#pragma region AI turn
	DWORD sub_GetQueueCommands;

	VOID __declspec(naked) StartAiTurnHook()
	{
		__asm {
			call sub_GetQueueCommands
			mov config.ai.turn, 0x1
			retn
		}
	}

	VOID __declspec(naked) EndAiTurnHook()
	{
		__asm {
			call sub_GetQueueCommands
			mov config.ai.turn, 0x0
			retn
		}
	}
#pragma endregion

#pragma region Sacred Lands
	HANDLE hInterf;
	BOOL isStrategic;
	DWORD* lineList;
	DWORD dlgObject;
	DWORD dlgStrategic;

	struct {
		DWORD pitch;
		BYTE* buffer;
	} hud;

	struct SlBlitObject {
		BYTE* data;
		INT pitch;
		DWORD unknown;
		RECT* rc;
	} slBLitObject;

	union
	{
		struct
		{
			DWORD iso01;
			DWORD iso02;
			DWORD isoWait;
			DWORD stra00;
			DWORD stra01;
			DWORD stra02;
		} game;
		struct
		{
			DWORD iso;
			DWORD pal;
			DWORD info;
			DWORD object;
			DWORD map;
			DWORD land;
			DWORD except;
		} editor;
	} dlgAddress;

	union
	{
		struct {
			Stream iso;
			Stream isoView;
			Stream stra;
			Stream straSpell;
			Stream straWait;
		} game;
		struct {
			Stream iso;
			Stream map;
			Stream land;
			Stream except;
		} editor;
	} dlgResources;

	VOID __stdcall CheckBordersV1()
	{
		if (config.type.editor)
			config.borders.active = dlgObject;
		else
			config.borders.active = !dlgStrategic || dlgObject;
	}

	DWORD** __fastcall LoadImageV1(DWORD** object, CHAR* name)
	{
		if (object[0] && object[1])
		{
			if (!config.type.editor)
			{
				if (!StrCompare(name, "ISOX01IX"))
					dlgAddress.game.iso01 = object[1][1];
				else if (!StrCompare(name, "ISOX02IX"))
					dlgAddress.game.iso02 = object[1][1];
				else if (!StrCompare(name, "ISOWAIT"))
					dlgAddress.game.isoWait = object[1][1];
				else if (!StrCompare(name, "STRA00IX"))
					dlgAddress.game.stra00 = object[1][1];
				else if (!StrCompare(name, "STRA01IX"))
					dlgAddress.game.stra01 = object[1][1];
				else if (!StrCompare(name, "STRA02IX"))
					dlgAddress.game.stra02 = object[1][1];
			}
			else
			{
				if (!StrCompare(name, "DLG_ISO"))
					dlgAddress.editor.iso = object[1][1];
				else if (!StrCompare(name, "DL_IPAL"))
					dlgAddress.editor.pal = object[1][1];
				else if (!StrCompare(name, "DLG_INFO"))
					dlgAddress.editor.info = object[1][1];
				else if (!StrCompare(name, "DLG_OBJ"))
					dlgAddress.editor.object = object[1][1];
				else if (!StrCompare(name, "DLG_MAP"))
					dlgAddress.editor.map = object[1][1];
				else if (!StrCompare(name, "DLG_LAND"))
					dlgAddress.editor.land = object[1][1];
				else if (!StrCompare(name, "DL_EXCE"))
					dlgAddress.editor.except = object[1][1];
			}
		}

		return object;
	}

	VOID __declspec(naked) hook_004F0B39()
	{
		__asm
		{
			pop ebx
			leave

			mov ecx, eax
			mov edx, [esp+0x8]
			call LoadImageV1
			retn 0x8
		}
	}

	VOID BlitHUD(BYTE* dstData, INT dstPitch, BYTE* srcData, INT srcPitch, Rect* srcRect, Rect* dstRect, BOOL revX, BOOL revY)
	{
		if (dstRect->width && dstRect->height)
		{
			srcData += srcRect->y * srcPitch + srcRect->x;
			dstData += dstRect->y * dstPitch + dstRect->x;

			if (revX)
				srcData += srcRect->width - 1;

			if (revY)
			{
				srcData += (srcRect->height - 1) * srcPitch;
				srcPitch = -srcPitch;
			}

			INT height = dstRect->height;
			do
			{
				if (!revX)
					MemoryCopy(dstData, srcData, dstRect->width);
				else
				{
					BYTE* src = srcData;
					BYTE* dst = dstData;

					INT width = dstRect->width;
					do
						*dst++ = *src--;
					while (--width);
				}

				srcData += srcPitch;
				dstData += dstPitch;
			} while (--height);
		}
	}

	VOID ClearHUD(BYTE* data, INT pitch, Rect* rect)
	{
		if (rect->width && rect->height)
		{
			data += rect->y * pitch + rect->x;

			LONG height = rect->height;
			do
			{
				MemoryZero(data, rect->width);
				data += pitch;
			} while (--height);
		}
	}

	VOID __stdcall StartDecodeImage(DWORD object, SlBlitObject* surface)
	{
		if (!config.type.editor)
		{
			if (object == dlgAddress.game.iso01)
			{
				RECT check = { 0, 0, *(LONG*)&config.mode->width - 640 + 464, *(LONG*)&config.mode->height };

				if (surface->rc)
				{
					if (!MemoryCompare(surface->rc, &check, sizeof(RECT)))
					{
						slBLitObject.data = surface->data;
						slBLitObject.pitch = surface->pitch;

						surface->data = hud.buffer;
						surface->pitch = hud.pitch;
					}
					else
					{
						check = { 64, *(LONG*)&config.mode->height - 480 + 452, 91, *(LONG*)&config.mode->height - 480 + 472 };
						RECT check2 = { 91, *(LONG*)&config.mode->height - 480 + 453, 414, *(LONG*)&config.mode->height - 480 + 470 };

						// bottom bar
						if (!MemoryCompare(surface->rc, &check, sizeof(RECT)) || !MemoryCompare(surface->rc, &check2, sizeof(RECT)))
						{
							Rect srcRect = { surface->rc->left, 480 - *(INT*)&config.mode->height + surface->rc->top, surface->rc->right - surface->rc->left, surface->rc->bottom - surface->rc->top };
							Rect dstRect = { srcRect.x, surface->rc->top, srcRect.width, srcRect.height };

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);
						}
					}
				}
			}
			else if (object == dlgAddress.game.iso02)
			{
				RECT check = { *(LONG*)&config.mode->width - 640 + 463, 0, *(LONG*)&config.mode->width, 201 };

				if (surface->rc && !MemoryCompare(surface->rc, &check, sizeof(RECT)))
				{
					slBLitObject.data = surface->data;
					slBLitObject.pitch = surface->pitch;

					surface->data = hud.buffer;
					surface->pitch = hud.pitch;
				}
			}
			else if (object == dlgAddress.game.isoWait || object == dlgAddress.game.stra00 || object == dlgAddress.game.stra01 || object == dlgAddress.game.stra02)
			{
				RECT check = { *(LONG*)&config.mode->width - 640 + 463, 201, *(LONG*)&config.mode->width, *(LONG*)&config.mode->height };

				if (surface->rc && !MemoryCompare(surface->rc, &check, sizeof(RECT)))
				{
					slBLitObject.data = surface->data;
					slBLitObject.pitch = surface->pitch;

					surface->data = hud.buffer;
					surface->pitch = hud.pitch;
				}
			}
		}
		else
		{
			if (object == dlgAddress.editor.iso)
			{
				RECT check = { 0, 0, *(LONG*)&config.mode->width - 640 + 461, *(LONG*)&config.mode->height };

				if (surface->rc && !MemoryCompare(surface->rc, &check, sizeof(RECT)))
				{
					slBLitObject.data = surface->data;
					slBLitObject.pitch = surface->pitch;

					surface->data = hud.buffer;
					surface->pitch = hud.pitch;
				}
			}
			else if (object == dlgAddress.editor.info || object == dlgAddress.editor.object || object == dlgAddress.editor.map || object == dlgAddress.editor.land || object == dlgAddress.editor.except)
			{
				RECT check = { *(LONG*)&config.mode->width - 640 + 461, 215, *(LONG*)&config.mode->width, 480 };

				if (surface->rc && !MemoryCompare(surface->rc, &check, sizeof(RECT)))
				{
					slBLitObject.data = surface->data;
					slBLitObject.pitch = surface->pitch;

					surface->data = hud.buffer;
					surface->pitch = hud.pitch;
				}
			}
		}
	}

	VOID __declspec(naked) hook_004F12D6()
	{
		__asm
		{
			pop eax
			push edi
			mov edi, [esp+0x30]
			push eax

			mov eax, [esp+0x28]
			push edi
			push eax
			call StartDecodeImage

			retn
		}
	}

	VOID __stdcall EndDecodeImage(DWORD object, POINT pos, SlBlitObject* surface, DWORD func, DWORD a6)
	{
		if (surface->data == hud.buffer)
		{
			surface->data = slBLitObject.data;
			surface->pitch = slBLitObject.pitch;

			if (!config.type.editor)
			{
				if (object == dlgAddress.game.iso01)
				{
					// main
					{
						Rect rect = { 0, 0, 463, 480 };
						ClearHUD(surface->data, surface->pitch, &rect);
					}

					Rect srcRect, dstRect;

					// top bar
					{
						srcRect = { 0, 0, 463, 26 };
						dstRect = srcRect;

						INT max = *(INT*)&config.mode->width - 177;
						BOOL rev = FALSE;
						for (INT i = dstRect.x; i < max; i += dstRect.width)
						{
							dstRect.x = i;

							INT min = max - i;
							dstRect.width = min < dstRect.width ? min : dstRect.width;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, rev, FALSE);

							rev = !rev;
						}
					}

					// left bar
					{
						srcRect = { 0, 26, 15, 454 - 42 };
						dstRect = srcRect;

						INT max = *(INT*)&config.mode->height - 42;
						BOOL rev = FALSE;
						for (INT j = dstRect.y; j < max; j += dstRect.height)
						{
							dstRect.y = j;

							INT min = max - j;
							dstRect.height = min < dstRect.height ? min : dstRect.height;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, rev);

							rev = !rev;
						}

						srcRect = { 0, 480 - 42, 15, 42 };
						dstRect = { 0, *(INT*)&config.mode->height - 42, 15, 42 };
						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);
					}

					// bottom bar
					{
						srcRect = { 15, 480 - 35, 59, 35 };
						dstRect = { 15, *(INT*)&config.mode->height - 35, 59, 35 };
						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);

						srcRect = { 640 - 239, 480 - 35, 62, 35 };
						dstRect = { *(INT*)&config.mode->width - 239, *(INT*)&config.mode->height - 35, 62, 35 };
						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);

						srcRect = { 74, 480 - 35, 327, 35 };
						dstRect = { 74, *(INT*)&config.mode->height - 35, 327, 35 };

						INT max = *(INT*)&config.mode->width - 239;
						BOOL rev = FALSE;
						for (INT i = dstRect.x; i < max; i += dstRect.width)
						{
							dstRect.x = i;

							INT min = max - i;
							dstRect.width = min < dstRect.width ? min : dstRect.width;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, rev, FALSE);

							rev = !rev;
						}

						srcRect = { 64, *(INT*)&config.mode->height - 35, 350, 35 };
						dstRect = { 64, 480 - 35, 350, 35 };

						BlitHUD(hud.buffer, hud.pitch, surface->data, surface->pitch, &srcRect, &dstRect, FALSE, FALSE);
					}
				}
				else if (object == dlgAddress.game.iso02)
				{
					surface->data = slBLitObject.data;
					surface->pitch = slBLitObject.pitch;

					// main
					Rect rect = { surface->rc->left, surface->rc->top, surface->rc->right - surface->rc->left, surface->rc->bottom - surface->rc->top };
					BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &rect, &rect, FALSE, FALSE);
				}
				else if (object == dlgAddress.game.isoWait || object == dlgAddress.game.stra00 || object == dlgAddress.game.stra01 || object == dlgAddress.game.stra02)
				{
					surface->data = slBLitObject.data;
					surface->pitch = slBLitObject.pitch;

					// main
					{
						Rect rect = { *(INT*)&config.mode->width - 177, 201, 177, 480 - 201 - 35 };
						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &rect, &rect, FALSE, FALSE);
					}

					// bottom bar
					{
						Rect srcRect = { *(INT*)&config.mode->width - 177, 480 - 35, 177, 35 };
						Rect dstRect = { *(INT*)&config.mode->width - 177, *(INT*)&config.mode->height - 35, 177, 35 };
						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);

						srcRect = { *(INT*)&config.mode->width - 177, 27, 177, 158 };
						dstRect = { *(INT*)&config.mode->width - 177, 480 - 35, 177, 158 };

						INT max = *(INT*)&config.mode->height - 35;
						INT min = max - dstRect.y;
						dstRect.height = min < dstRect.height ? min : dstRect.height;

						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);

						srcRect = { *(INT*)&config.mode->width - 177, 32, 177, 153 };
						dstRect = { *(INT*)&config.mode->width - 177, 480 - 35 + 158, 177, 153 };

						BOOL rev = TRUE;
						for (INT j = dstRect.y; j < max; j += dstRect.height)
						{
							dstRect.y = j;

							INT min = max - dstRect.y;
							dstRect.height = min < dstRect.height ? min : dstRect.height;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, rev);

							rev = !rev;
						}
					}
				}
			}
			else
			{
				if (object == dlgAddress.editor.iso)
				{
					// main
					{
						Rect rect = { 0, 0, 461, 480 };
						ClearHUD(surface->data, surface->pitch, &rect);
					}

					Rect srcRect, dstRect;

					// top bar
					{
						srcRect = { 0, 0, 13, 31 };
						dstRect = srcRect;

						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);

						srcRect = { 13, 0, 448, 31 };
						dstRect = srcRect;

						INT max = *(INT*)&config.mode->width - 640 + 461;
						BOOL rev = FALSE;
						for (INT i = dstRect.x; i < max; i += dstRect.width)
						{
							dstRect.x = i;

							INT min = max - i;
							dstRect.width = min < dstRect.width ? min : dstRect.width;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, rev, FALSE);

							rev = !rev;
						}
					}

					// body
					{
						srcRect = { 13, 31, 448, 420 };
						dstRect = srcRect;

						INT maxX = *(INT*)&config.mode->width - 640 + 461;
						INT maxY = *(INT*)&config.mode->height - 29;

						for (INT j = srcRect.y; j < maxY; j += srcRect.height)
						{
							dstRect.y = j;

							INT min = maxY - j;
							dstRect.height = min < srcRect.height ? min : srcRect.height;

							for (INT i = srcRect.x; i < maxX; i += srcRect.width)
							{
								dstRect.x = i;

								min = maxX - i;
								dstRect.width = min < srcRect.width ? min : srcRect.width;

								BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);
							}
						}
					}

					// left bar
					{
						srcRect = { 0, 31, 13, 420 };
						dstRect = srcRect;

						INT max = *(INT*)&config.mode->height - 29;
						BOOL rev = FALSE;
						for (INT j = dstRect.y; j < max; j += dstRect.height)
						{
							dstRect.y = j;

							INT min = max - j;
							dstRect.height = min < dstRect.height ? min : dstRect.height;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, rev);

							rev = !rev;
						}
					}

					// bottom bar
					{
						srcRect = { 0, 451, 13, 29 };
						dstRect = { 0, *(INT*)&config.mode->height - 480 + 451, 13, 29 };

						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);

						srcRect = { 13, 451, 448, 29 };
						dstRect = { 13, *(INT*)&config.mode->height - 480 + 451, 448, 29 };

						INT max = *(INT*)&config.mode->width - 640 + 461;
						BOOL rev = FALSE;
						for (INT i = dstRect.x; i < max; i += dstRect.width)
						{
							dstRect.x = i;

							INT min = max - i;
							dstRect.width = min < dstRect.width ? min : dstRect.width;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, rev, FALSE);

							rev = !rev;
						}
					}
				}
				else if (object == dlgAddress.editor.info || object == dlgAddress.editor.object || object == dlgAddress.editor.map || object == dlgAddress.editor.land || object == dlgAddress.editor.except)
				{
					Rect srcRect, dstRect;

					// left bar
					{
						srcRect = { *(INT*)&config.mode->width - 640 + 461, 215, 179, 236 };
						dstRect = srcRect;

						INT max = *(INT*)&config.mode->height - 2;
						BOOL rev = FALSE;
						for (INT j = dstRect.y; j < max; j += dstRect.height)
						{
							dstRect.y = j;

							INT min = max - j;
							dstRect.height = min < dstRect.height ? min : dstRect.height;

							BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, rev);

							rev = !rev;
						}
					}

					{
						srcRect = { *(INT*)&config.mode->width - 640 + 461, 451, 2, 29 };
						dstRect = { *(INT*)&config.mode->width - 640 + 461, *(INT*)&config.mode->height - 480 + 451, 2, 29 };

						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);
					}

					{
						srcRect = { *(INT*)&config.mode->width - 640 + 461 + 2, 478, 177, 2 };
						dstRect = { *(INT*)&config.mode->width - 640 + 461 + 2, *(INT*)&config.mode->height - 2, 177, 2 };

						BlitHUD(surface->data, surface->pitch, hud.buffer, hud.pitch, &srcRect, &dstRect, FALSE, FALSE);
					}
				}
			}
		}
	}

	VOID __declspec(naked) hook_004F157A()
	{
		__asm
		{
			mov [esp+0x30], edi

			pop edi
			pop esi
			pop ebp
			pop ebx
			add esp, 0x10
			jmp EndDecodeImage
		}
	}

	VOID __stdcall CreateIsoDialog(CHAR* name)
	{
		isStrategic = !StrCompare(name, "DLG_STRATEGIC") || !StrCompare(name, "DLG_STRAT_WAIT");
		CheckBordersV1();
	}

	DWORD off_0046541D;
	VOID __declspec(naked) hook_0046541D()
	{
		__asm
		{
			push ecx
			mov eax, [esp+0x10]
			push eax
			call CreateIsoDialog

			pop ecx
			mov eax, off_0046541D
			retn
		}
	}

	VOID __stdcall CreateViewDialog(CHAR** name, POINT* p1, POINT* p2)
	{
		if (config.type.editor)
		{
			if (!StrCompare(*name, "DLG_ISO"))
			{
				p2->x = config.mode->width;
				p2->y = config.mode->height;
			}
			else if (!StrCompare(*name, "DLG_ISO_PAL"))
			{
				p1->x = config.mode->width - 640 + 461;
				p2->x = config.mode->width;
				p2->y = config.mode->height;
			}
			else if (!StrCompare(*name, "DLG_INFO") || !StrCompare(*name, "DLG_OBJECTS"))
			{
				p1->x = config.mode->width - 640 + 461;
				p2->x = config.mode->width;
				p2->y = config.mode->height;
			}
			else if (!StrCompare(*name, "DLG_MAP"))
			{
				p1->x = config.mode->width - 640 + 461;
				p2->x = config.mode->width;
				p2->y = config.mode->height;
			}
			else if (!StrCompare(*name, "DLG_LANDMARK"))
			{
				p1->x = config.mode->width - 640 + 461;
				p2->x = config.mode->width;
				p2->y = config.mode->height;
			}
			else if (!StrCompare(*name, "DLG_EXCEPTIONAL"))
			{
				p1->x = config.mode->width - 640 + 461;
				p2->x = config.mode->width;
				p2->y = config.mode->height;
			}
		}
		else if (isStrategic)
		{
			if (!StrCompare(*name, "DLG_ISO_VIEW"))
				*name = "DLG_ISO_VIEW_NEW";
			else if (!StrCompare(*name, "DLG_ISO"))
				*name = "DLG_ISO_NEW";
		}
	}

	DWORD off_0055106A;
	VOID __declspec(naked) hook_0055106A()
	{
		__asm
		{
			push ecx
			mov eax, [esp+0x1C]
			push eax
			mov eax, [esp+0x1C]
			push eax
			lea eax, [esp+0x18]
			push eax
			call CreateViewDialog

			pop ecx
			mov eax, off_0055106A

			retn
		}
	}

	HANDLE __stdcall CreateFileHook(LPCSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD dwCreationDisposition, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
	{
		HANDLE hFile = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, dwFlagsAndAttributes, hTemplateFile);

		CHAR* p = StrLastChar((CHAR*)lpFileName, '\\');
		if (p && !StrCompareInsensitive(p, !config.type.editor ? "\\Interf.dlg" : "\\ScenEdit.dlg"))
			hInterf = hFile;

		return hFile;
	}

	DWORD CalcStrNumbers(Stream* stream)
	{
		DWORD res = 0;
		BOOL found = FALSE;
		CHAR* p = (CHAR*)stream->data;
		DWORD size = stream->size;

		if (size)
		{
			while (--size)
			{
				if (p[0] == '%' && p[1] == 'd')
				{
					++res;
					++p;
					--size;
				}

				++p;
			}
		}

		return res;
	}

	DWORD __stdcall GetFileSizeHook(HANDLE hFile, LPDWORD lpFileSizeHigh)
	{
		DWORD size = GetFileSize(hFile, lpFileSizeHigh);

		if (hInterf && hFile == hInterf)
		{
			if (!config.type.editor)
			{
				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_ISO_NEW), &dlgResources.game.iso))
					size += dlgResources.game.iso.size + CalcStrNumbers(&dlgResources.game.iso) * 9 + 4;

				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_ISO_VIEW_NEW), &dlgResources.game.isoView))
					size += dlgResources.game.isoView.size + CalcStrNumbers(&dlgResources.game.isoView) * 9 + 4;

				if (Main::LoadResource(MAKEINTRESOURCE(config.version.major.value >= (NUM(99, 12)) ? IDR_DLG_STRATEGIC_NEW : IDR_DLG_STRATEGIC_OLD), &dlgResources.game.stra))
					size += dlgResources.game.stra.size + CalcStrNumbers(&dlgResources.game.stra) * 9 + 4;

				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_STRAT_SPELL_NEW), &dlgResources.game.straSpell))
					size += dlgResources.game.straSpell.size + CalcStrNumbers(&dlgResources.game.straSpell) * 9 + 4;

				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_STRAT_WAIT_NEW), &dlgResources.game.straWait))
					size += dlgResources.game.straWait.size + CalcStrNumbers(&dlgResources.game.straWait) * 9 + 4;
			}
			else
			{
				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_ISO_EDIT), &dlgResources.editor.iso))
					size += dlgResources.editor.iso.size + CalcStrNumbers(&dlgResources.editor.iso) * 9 + 4;

				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_MAP_EDIT), &dlgResources.editor.map))
					size += dlgResources.editor.map.size + CalcStrNumbers(&dlgResources.editor.map) * 9 + 4;

				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_LANDMARK_EDIT), &dlgResources.editor.land))
					size += dlgResources.editor.land.size + CalcStrNumbers(&dlgResources.editor.land) * 9 + 4;

				if (Main::LoadResource(MAKEINTRESOURCE(IDR_DLG_EXCEPTIONAL_EDIT), &dlgResources.editor.except))
					size += dlgResources.editor.except.size + CalcStrNumbers(&dlgResources.editor.except) * 9 + 4;
			}
		}

		return size;
	}

	VOID FormatDialog(Stream* stream, CHAR** buffer, ...)
	{
		CHAR* format = (CHAR*)MemoryAlloc(stream->size + 1);
		if (format)
		{
			MemoryCopy(format, stream->data, stream->size);
			format[stream->size] = NULL;

			va_list args;
			va_start(args, buffer);
			StrPrintVar(*buffer, format, args);
			va_end(args);

			MemoryFree(format);

			*buffer += StrLength(*buffer);
			StrCopy(*buffer, "\r\n\r\n");
			*buffer += 4;
		}
	}

	BOOL __stdcall ReadFileHook(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped)
	{
		DWORD read = 0;

		if (hInterf && hFile == hInterf)
		{
			DisplayMode* mode = config.mode;
			CHAR* dst = (CHAR*)lpBuffer;

			if (!config.type.editor)
			{
				FormatDialog(&dlgResources.game.iso, &dst, mode->width - 640 + 464, mode->height,
					mode->height - 480 + 453, mode->height - 480 + 470,
					mode->width - 640 + 464, mode->height - 480 + 445,
					mode->height - 480 + 452, mode->height - 480 + 472);

				FormatDialog(&dlgResources.game.isoView, &dst, mode->width, mode->height,
					mode->width - 640 + 464, mode->height,
					mode->width - 640 + 463, mode->width,
					mode->width - 640 + 463, mode->width);

				FormatDialog(&dlgResources.game.stra, &dst, mode->height - 480 + 279,
					mode->height - 480 + 244, mode->height - 480 + 279,
					mode->height - 480 + 254, mode->height - 480 + 274);

				FormatDialog(&dlgResources.game.straSpell, &dst, mode->height - 480 + 279);
				FormatDialog(&dlgResources.game.straWait, &dst, mode->height - 480 + 279);
			}
			else
			{
				FormatDialog(&dlgResources.editor.iso, &dst, mode->width - 640 + 461, mode->height,
					mode->width - 640 + 461, mode->height - 480 + 451);

				FormatDialog(&dlgResources.editor.map, &dst);
				FormatDialog(&dlgResources.editor.land, &dst);
				FormatDialog(&dlgResources.editor.except, &dst);
			}

			read = dst - (CHAR*)lpBuffer;
			nNumberOfBytesToRead -= read;
			lpBuffer = dst;
		}

		if (ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped))
		{
			*lpNumberOfBytesRead += read;
			return TRUE;
		}

		return FALSE;
	}

	BOOL __stdcall CloseHandleHook(HANDLE hObject)
	{
		if (hInterf && hObject == hInterf)
			hInterf = NULL;

		return CloseHandle(hObject);
	}

	VOID __stdcall PopolateList(DWORD** object, Size* size)
	{
		object[2] = lineList;

		DWORD total = 0;
		DWORD* item = lineList;

		for (DWORD i = size->height; i; --i)
		{
			*item++ = total;
			total += size->width;
		}
	}

	VOID __stdcall DialogCreateHook(DWORD** object, CHAR* name)
	{
		if (!config.type.editor)
		{
			const CHAR* dialogs[] = {
				"DLG_CHOOSE_LORD",
				"DLG_CHOOSE_RACE",
				"DLG_CHOOSE_SKIRMISH",
				"DLG_HOST",
				"DLG_LOAD",
				"DLG_LOAD_NEW_MULTI",
				"DLG_LOAD_SKIRMISH",
				"DLG_LOAD_TOURNEMENT",
				"DLG_LOBBY",
				"DLG_MAIN_MENU",
				"DLG_PROTOCOL",
				"DLG_SESSION",
				"DLG_SINGLE_PLAYER",
				"DLG_WAIT",

				"DLG_CAST_SPELL",
				"DLG_BATTLE",
				"DLG_BUILD_STRUCTURE",
				"DLG_CARRY_ITEM_LEADER",
				"DLG_CITY_STACK",
				"DLG_END_WIN_LOSE",
				"DLG_EXCHANGE",
				"DLG_FAKE_CARRY_OVER",
				"DLG_KNOWN_SPELL",
				"DLG_LOAD_GAME",
				"DLG_MAGE",
				"DLG_MANAGE_STACK",
				"DLG_MERCENARIES",
				"DLG_MERCHANT",
				"DLG_OPTIONS",
				"DLG_PICKUP_DROP",
				"DLG_RESEARCH_SPELL",
				"DLG_SAVE_GAME",
				"DLG_SCENARIO_BRIEFING",
				"DLG_THIEF_ACTIONS",
				"DLG_TRADE_ITEM",
				"DLG_TRADE_SPELL",
				"DLG_TRAINING_CAMP",
				"DLG_WAND_SCROLL",
				"DLG_CAPITAL",
				"DLG_CITY",
				"DLG_DIPLOMACY"
			};

			if (!StrCompare(name, "DLG_STRATEGIC") || !StrCompare(name, "DLG_STRAT_WAIT") || !StrCompare(name, "DLG_STRAT_SPELL"))
			{
				dlgStrategic = (DWORD)object;
				CheckBordersV1();
			}

			if (dlgStrategic && !dlgObject)
			{
				const CHAR** dlg = dialogs;
				DWORD count = sizeof(dialogs) / sizeof(CHAR*);
				do
				{
					if (!StrCompare(name, *dlg))
					{
						dlgObject = (DWORD)object;
						CheckBordersV1();
						break;
					}

					++dlg;
				} while (--count);
			}
		}
		else
		{
			const CHAR* dialogs[] = {
				"DLG_DELETE_MAP",
				"DLG_EDIT_MAP",
				"DLG_EXPORT_MAP",
				"DLG_IMPORT_MAP",
				"DLG_MAIN_MENU",
				"DLG_NEW_MAP"
			};

			if (!dlgObject)
			{
				const CHAR** dlg = dialogs;
				DWORD count = sizeof(dialogs) / sizeof(CHAR*);
				do
				{
					if (!StrCompare(name, *dlg))
					{
						dlgObject = (DWORD)object;
						CheckBordersV1();
						break;
					}

					++dlg;
				} while (--count);
			}
		}
	}

	VOID __declspec(naked) hook_004E746D()
	{
		__asm {
			mov eax, [ecx]
			call dword ptr [eax+0xC]
			push eax

			push eax
			push esi
			call DialogCreateHook

			pop eax
			retn
		}
	}

	DWORD __fastcall DialogDeleteHook(DWORD object)
	{
		if (dlgStrategic == object)
		{
			dlgStrategic = NULL;
			CheckBordersV1();
		}
		else if (dlgObject == object)
		{
			dlgObject = NULL;
			CheckBordersV1();
		}
		return object;
	}

	DWORD sub_004E74F1;
	VOID __declspec(naked) hook_004E74D8()
	{
		__asm
		{
			call DialogDeleteHook
			mov ecx, eax
			jmp sub_004E74F1
		}
	}
#pragma endregion

#pragma region Sphere fix
	VOID __declspec(naked) hook_00650628()
	{
		__asm {
			mov eax, config.mode
			mov eax, [eax]
			sar eax, 0x1
			add edx, eax

			mov eax, config.battle.wide
			test eax, eax
			jnz lbl_wide
			mov eax, GAME_WIDTH
			jmp lbl_cont

			lbl_wide:
			mov eax, WIDE_WIDTH

			lbl_cont:
			sar eax, 0x1
			sub edx, eax

			mov eax, [ebp-0x38]
			mov [eax], edx
			retn
		}
	}

	VOID __declspec(naked) hook_00650674()
	{
		__asm {
			mov eax, config.mode
			mov eax, [eax+0x4]
			sar eax, 0x1
			add edx, eax

			mov eax, config.battle.wide
			test eax, eax
			jnz lbl_wide
			mov eax, GAME_HEIGHT
			jmp lbl_cont

			lbl_wide:
			mov eax, WIDE_HEIGHT

			lbl_cont:
			sar eax, 0x1
			sub edx, eax

			mov eax, [ebp-0x40]
			mov [eax], edx
			retn
		}
	}
#pragma endregion

#pragma region Async Sounds
	VOID __stdcall NullPlayCallback(DWORD)
	{
	}

	DWORD sub_PlaySpell;
	VOID __declspec(naked) hook_004F21C0()
	{
		__asm {
			mov edx, [esp+0x8]
			mov eax, [edx+0x4]
			mov edx, NullPlayCallback
			mov [eax+0x8], edx
			mov edx, [eax+0x4]
			mov eax, [edx+0xC]
			mov byte ptr [eax+0xC], 0x1
			jmp sub_PlaySpell
		}
	}

	DWORD sub_PlayDeath;
	VOID __declspec(naked) hook_004EF722()
	{
		__asm {
			mov edx, [esp+0x8]
			mov eax, [edx+0x4]
			mov edx, NullPlayCallback
			mov [eax+0x8], edx
			mov edx, [eax+0x4]
			mov eax, [edx+0xC]
			mov byte ptr [eax+0x14], 0x1
			jmp sub_PlayDeath
		}
	}

	DWORD sub_PlayRuin;
	VOID __declspec(naked) hook_004F1D80()
	{
		__asm {
			mov edx, [esp+0xC]
			mov eax, [edx+0x4]
			mov edx, NullPlayCallback
			mov [eax+0x8], edx
			mov edx, [eax+0x4]
			mov eax, [edx+0x8]
			mov byte ptr [eax+0x5], 0x1
			jmp sub_PlayRuin
		}
	}
#pragma endregion

#pragma region Map move by mouse
#define LBUTTON 1
#define MBUTTON 2

	struct {
		POINT mapPos;
		POINT dlgPos;
		POINT checkPos;
		DWORD* dialog;
		DWORD button;
		BOOL moved;
		BYTE* allow;
		BOOL deleted;
		struct {
			DWORD area;
			DWORD keystate;
			struct {
				DWORD set;
				DWORD clear;
				DWORD get;
			} dialog;
		} offset;
		DWORD* radioObjects;
	} mouseAction;

	DWORD sub_CreateRadio;
	DWORD* __stdcall CreateRadioObjects(DWORD* obj, CHAR* name)
	{
		DWORD* res = ((DWORD * (__stdcall*)(DWORD*, CHAR*)) sub_CreateRadio)(obj, name);
		if (!StrCompare(name, "RAD_OBJECTS"))
			mouseAction.radioObjects = res;
		return res;
	}

	SHORT GetDialogKeyState(DWORD* dialog, INT iKey)
	{
		LOCK lock;
		DWORD**** lockMethod = (DWORD****)sub_BeginLock(&lock)[1];
		lock.flags = 0;
		SHORT res = ((SHORT(__stdcall*)(INT))lockMethod[1][1][0][22])(iKey); // key state
		lock.flags = -1;
		sub_EndLock(&lock, NULL);

		return res;
	}

	VOID SetCurrentDialog(DWORD* dialog)
	{
		LOCK lock;
		DWORD** lockMethod = (DWORD**)sub_BeginLock_2(&lock)[1];
		lock.flags = 0;
		((VOID(__thiscall*)(DWORD**, DWORD*))lockMethod[0][9])(lockMethod, dialog); // set
		lock.flags = -1;
		sub_EndLock_2(&lock, NULL);
	}

	VOID ClearCurrentDialog()
	{
		LOCK lock;
		DWORD** lockMethod = (DWORD**)sub_BeginLock_2(&lock)[1];
		lock.flags = 1;
		((VOID(__thiscall*)(DWORD**))lockMethod[0][10])(lockMethod); // clear
		lock.flags = -1;
		sub_EndLock_2(&lock, NULL);
	}

	DWORD* GetCurrentDialog()
	{
		LOCK lock;
		DWORD** lockMethod = (DWORD**)sub_BeginLock_2(&lock)[1];
		lock.flags = 1;
		DWORD* dialog = ((DWORD * (__thiscall*)(DWORD**)) lockMethod[0][11])(lockMethod); // get
		lock.flags = -1;
		sub_EndLock_2(&lock, NULL);

		return dialog;
	}

	DWORD sub_GetMapCenter, sub_SetMapCenter;

	DWORD sub_DeleteIsoView;
	VOID __declspec(naked) DeleteIsoView(DWORD obj)
	{
		__asm {
			mov mouseAction.deleted, 0x1
			jmp sub_DeleteIsoView
		}
	}

	DWORD sub_DeleteIsoInfoView;
	VOID __declspec(naked) DeleteIsoInfoView(DWORD obj)
	{
		__asm {
			mov mouseAction.deleted, 0x1
			jmp sub_DeleteIsoInfoView
		}
	}

	DWORD sub_DeleteIsoEventsView;
	VOID __declspec(naked) DeleteIsoEventsView(DWORD obj)
	{
		__asm {
			mov mouseAction.deleted, 0x1
			jmp sub_DeleteIsoEventsView
		}
	}

	DWORD sub_DeleteIsoMapView;
	VOID __declspec(naked) DeleteIsoMapView(DWORD obj)
	{
		__asm {
			mov mouseAction.deleted, 0x1
			jmp sub_DeleteIsoMapView
		}
	}

	DWORD sub_DeleteRadioObjects;
	VOID __declspec(naked) DeleteRadioObjects(DWORD obj)
	{
		__asm {
			cmp ecx, mouseAction.radioObjects
			jne lbl_cont
			mov mouseAction.radioObjects, 0x0

			lbl_cont:
			jmp sub_DeleteRadioObjects
		}
	}

	DWORD* GetAreaObject(VOID* global)
	{
		if (config.type.editor)
			return ((DWORD***)global)[4][6];
		else
			return ((DWORD**)global)[50];
	}

	DWORD sub_MouseAction;
	BOOL __fastcall MouseAction(DWORD* global, DWORD /*edx*/, UINT uMsg, POINT* pt)
	{
		if (*mouseAction.allow)
		{
			DWORD* obj = GetAreaObject(global);
			if (config.scroll.buttons.left && uMsg == WM_LBUTTONDOWN || config.scroll.buttons.middle && uMsg == WM_MBUTTONDOWN)
			{
				if (uMsg != WM_LBUTTONDOWN || !mouseAction.radioObjects || ((DWORD*)mouseAction.radioObjects[2])[5] != 7)
				{
					DWORD* methods = (DWORD*)obj[0];
					RECT* rc = ((RECT * (__thiscall*)(DWORD*)) methods[12])(obj);
					if (pt->x >= rc->left && pt->x < rc->right && pt->y >= rc->top && pt->y < rc->bottom && (rc->right - rc->left != config.mode->width || pt->x < rc->right - PANEL_WIDTH || pt->y >= rc->top + GAME_HEIGHT) && !GetCurrentDialog())
					{
						DWORD* mapObject = (DWORD*)((DWORD*)obj[2])[1];

						POINT offset;
						((BOOL(__thiscall*)(DWORD*, POINT*, LONG*, LONG*))sub_GetMapCenter)(mapObject, &mouseAction.mapPos, &offset.x, &offset.y); // Get Map Center
						mouseAction.dlgPos = { pt->x + offset.x, pt->y + offset.y };
						mouseAction.checkPos = *pt;
						mouseAction.dialog = global;
						mouseAction.button = uMsg == WM_LBUTTONDOWN ? LBUTTON : MBUTTON;
						mouseAction.moved = FALSE;

						SetCurrentDialog(global);
						return TRUE;
					}
				}
			}
			else if (mouseAction.dialog == global && (mouseAction.button == LBUTTON && uMsg == WM_LBUTTONUP || mouseAction.button == MBUTTON && uMsg == WM_MBUTTONUP))
			{
				mouseAction.dialog = NULL;
				mouseAction.button = NULL;

				ClearCurrentDialog();

				if (uMsg != WM_LBUTTONUP || mouseAction.moved)
				{
					DWORD* mapObject = (DWORD*)((DWORD*)obj[2])[1];
					((VOID(__thiscall*)(DWORD*, POINT*, LONG, LONG))sub_SetMapCenter)(mapObject, &mouseAction.mapPos, mouseAction.dlgPos.x - pt->x, mouseAction.dlgPos.y - pt->y);
				}
				else
				{
					mouseAction.deleted = FALSE;
					BOOL res = ((BOOL(__thiscall*)(DWORD*, UINT, POINT*))sub_MouseAction)(global, uMsg == WM_LBUTTONUP ? WM_LBUTTONDOWN : WM_MBUTTONDOWN, pt);
					if (mouseAction.deleted)
						return res;
				}
			}
		}

		return ((BOOL(__thiscall*)(DWORD*, UINT, POINT*))sub_MouseAction)(global, uMsg, pt);
	}

	DWORD sub_MouseActionMap;
	BOOL __fastcall MouseActionMap(DWORD* global, DWORD /*edx*/, UINT uMsg, POINT* pt)
	{
		if (*mouseAction.allow)
		{
			DWORD* obj = GetAreaObject(global);
			if (config.scroll.buttons.middle && uMsg == WM_MBUTTONDOWN)
			{
				DWORD* methods = (DWORD*)obj[0];
				RECT* rc = ((RECT * (__thiscall*)(DWORD*)) methods[12])(obj);
				if (pt->x >= rc->left && pt->x < rc->right && pt->y >= rc->top && pt->y < rc->bottom && (rc->right - rc->left != config.mode->width || pt->x < rc->right - PANEL_WIDTH || pt->y >= rc->top + GAME_HEIGHT) && !GetCurrentDialog())
				{
					DWORD* mapObject = (DWORD*)((DWORD*)obj[2])[1];

					POINT offset;
					((BOOL(__thiscall*)(DWORD*, POINT*, LONG*, LONG*))sub_GetMapCenter)(mapObject, &mouseAction.mapPos, &offset.x, &offset.y); // Get Map Center
					mouseAction.dlgPos = { pt->x + offset.x, pt->y + offset.y };
					mouseAction.checkPos = *pt;
					mouseAction.dialog = global;
					mouseAction.button = uMsg == WM_LBUTTONDOWN ? LBUTTON : MBUTTON;
					mouseAction.moved = FALSE;

					SetCurrentDialog(global);
					return TRUE;
				}
			}
			else if (mouseAction.dialog == global && mouseAction.button == MBUTTON && uMsg == WM_MBUTTONUP)
			{
				mouseAction.dialog = NULL;
				mouseAction.button = NULL;

				ClearCurrentDialog();

				DWORD* mapObject = (DWORD*)((DWORD*)obj[2])[1];
				((VOID(__thiscall*)(DWORD*, POINT*, LONG, LONG))sub_SetMapCenter)(mapObject, &mouseAction.mapPos, mouseAction.dlgPos.x - pt->x, mouseAction.dlgPos.y - pt->y);
			}
		}

		return ((BOOL(__thiscall*)(DWORD*, UINT, POINT*))sub_MouseActionMap)(global, uMsg, pt);
	}

	DWORD sub_MouseMove;
	BOOL __fastcall MouseMove(DWORD* global, DWORD /*edx*/, POINT* pt)
	{
		if (*mouseAction.allow && mouseAction.dialog == global)
		{
			if (mouseAction.button == LBUTTON && GetDialogKeyState(global, VK_LBUTTON) || mouseAction.button == MBUTTON && GetDialogKeyState(global, VK_MBUTTON))
			{
				if (mouseAction.button == LBUTTON && !mouseAction.moved)
				{
					LONG x = mouseAction.checkPos.x - pt->x;
					LONG y = mouseAction.checkPos.y - pt->y;
					mouseAction.moved = (LONG)MathSqrtFloat(FLOAT(x * x + y * y)) >= 32;
				}

				if (mouseAction.button != LBUTTON || mouseAction.moved)
				{
					DWORD* obj = GetAreaObject(global);

					DWORD* mapObject = (DWORD*)((DWORD*)obj[2])[1];
					((VOID(__thiscall*)(DWORD*, POINT*, LONG, LONG))sub_SetMapCenter)(mapObject, &mouseAction.mapPos, mouseAction.dlgPos.x - pt->x, mouseAction.dlgPos.y - pt->y);

					POINT offset, mapPos;
					((VOID(__thiscall*)(DWORD*, POINT*, LONG*, LONG*))sub_GetMapCenter)(mapObject, &mapPos, &offset.x, &offset.y); // Get Map Center

					// To map offset
					offset = { offset.y * 2 + offset.x, offset.y * 2 - offset.x };

					LONG size = ((LONG*)mapObject[0])[5];

					BOOL reset = FALSE;
					if (mapPos.x < 0 || !mapPos.x && offset.x < 0)
					{
						mapPos.x = 0;
						offset.x = 0;
						reset = TRUE;
					}
					else if (mapPos.x >= size || mapPos.x == size - 1 && offset.x > 0)
					{
						mapPos.x = size - 1;
						offset.x = 0;
						reset = TRUE;
					}

					if (mapPos.y < 0 || !mapPos.y && offset.y < 0)
					{
						mapPos.y = 0;
						offset.y = 0;
						reset = TRUE;
					}
					else if (mapPos.y >= size || mapPos.y == size - 1 && offset.y > 0)
					{
						mapPos.y = size - 1;
						offset.y = 0;
						reset = TRUE;
					}

					if (reset)
					{
						// To screen offset
						offset = { (offset.x - offset.y) / 2, (offset.x + offset.y) / 4 };

						mouseAction.mapPos = mapPos;
						mouseAction.dlgPos = { pt->x + offset.x, pt->y + offset.y };

						((VOID(__thiscall*)(DWORD*, POINT*, LONG, LONG))sub_SetMapCenter)(mapObject, &mouseAction.mapPos, offset.x, offset.y);
					}

					return TRUE;
				}
			}
			else
			{
				mouseAction.dialog = NULL;
				mouseAction.button = NULL;

				if (GetCurrentDialog() == global)
					ClearCurrentDialog();
			}
		}

		return ((BOOL(__thiscall*)(DWORD*, POINT*))sub_MouseMove)(global, pt);
	}
#pragma endregion

#pragma region Banners and resources popup
	BYTE* flagResPopup;
	VOID __cdecl SetResources(DWORD value)
	{
		*flagResPopup = value & 1;
		config.toogle.resources = *flagResPopup;
		Config::Set(CONFIG_WRAPPER, "ShowResources", config.toogle.resources);
	}

	VOID __declspec(naked) hook_004869CB()
	{
		__asm {
			push eax
			call SetResources
			pop eax
			cmp al, bl
			retn
		}
	}

	VOID __stdcall SetBanners(DWORD value)
	{
		config.toogle.banners = value & 1;
		Config::Set(CONFIG_WRAPPER, "ShowBanners", config.toogle.banners);
	}

	VOID __declspec(naked) hook_005AED25()
	{
		__asm {
			mov [ecx], al
			push eax
			call SetBanners
			retn 0x4
		}
	}

	DWORD sub_SpinOwnerCallback;
	VOID __declspec(naked) hook_SpinOwnerCallback()
	{
		__asm {
			mov eax, [ecx+0x20]
			mov byte ptr [eax+0x3C], 0x1
			jmp sub_SpinOwnerCallback
		}
	}

#pragma endregion

#pragma region Sort scenarios by title
	COPYSTRING CopyString;
	PRINTSTRING PrintString;

	BOOL __stdcall CompareScenes(SceneObject* scene1, SceneObject* scene2)
	{
		switch (config.scene.sort.real)
		{
		case SceneBySizeAsc:
		case SceneBySizeDesc: {
			if (scene1->size != scene2->size)
				return config.scene.sort.real == SceneBySizeAsc ? scene1->size < scene2->size : scene1->size > scene2->size;
		}

		case SceneByTitle: {
			INT res = StrCompareInsensitive(scene1->title.text, scene2->title.text);
			if (res)
				return res < 0;
		}

		default:
			break;
		}

		CHAR* ptr1 = StrLastChar(scene1->fileName.text, '\\');
		CHAR* ptr2 = StrLastChar(scene2->fileName.text, '\\');

		if (!ptr1 || !*(++ptr1))
			ptr1 = scene1->fileName.text;

		if (!ptr2 || !*(++ptr2))
			ptr1 = scene1->fileName.text;

		return StrCompareInsensitive(ptr1, ptr2) < 0;
	}

	DWORD sub_GetScenariosSortedList;
	DWORD __fastcall GetScenariosSortedList(VOID* obj, DWORD /*edx*/, CHAR* dir, DWORD a3, DWORD a4, VOID* callback)
	{
		return ((DWORD(__thiscall*)(VOID*, CHAR*, DWORD, DWORD, VOID*))sub_GetScenariosSortedList)(obj, dir, a3, a4, CompareScenes);
	}

	DWORD sub_CopyStrObject;
	StringObject* __fastcall AddScenarioSize(StringObject* dst, DWORD /*edx*/, StringObject* sceneTitle)
	{
		const CHAR* pattern = "%SCEN%\\hR;%SIZE%";

		SceneObject* scene = (SceneObject*)((DWORD)sceneTitle - 56);

		INT first, last;
		CHAR* ch = scene->title.text;
		if (!*ch)
			first = last = 0;
		else
		{
			first = last = -1;
			INT idx = 0;
			do
			{
				if (!IsSpace(*ch++))
				{
					if (first == -1)
						first = idx;

					last = idx + 1;
				}

				++idx;
			} while (*ch);
		}

		DWORD length = last - first;
		CHAR* buf = (CHAR*)MemoryAlloc(length + 1);
		{
			if (length)
				MemoryCopy(buf, &scene->title.text[first], length);
			buf[length] = NULL;

			CHAR size[16];
			StrPrint(size, "%d x %d", scene->size, scene->size);

			MemoryZero(dst, sizeof(StringObject));
			CopyString(dst, pattern, StrLength(pattern));
			PrintString(dst, "%SCEN%", buf);
			PrintString(dst, "%SIZE%", size);
		}
		MemoryFree(buf);

		return dst;
	}
#pragma endregion

#pragma region Config
	DWORD __stdcall GetPrivateProfileStringHook(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName)
	{
		if (!StrCompare(lpKeyName, "ForceD3DPow2") && !StrCompare(lpAppName, CONFIG_DISCIPLE))
		{
			StrCopy(lpReturnedString, "0");
			return 1;
		}

		return GetPrivateProfileString(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
	}
#pragma endregion

#pragma region No CD
	LSTATUS __stdcall RegOpenKeyExHook(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult)
	{
		return ERROR_SUCCESS;
	}

	LSTATUS __stdcall RegQueryValueExHook(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData)
	{
		*lpType = REG_BINARY;
		*(DWORD*)lpData = '1111';
		return ERROR_SUCCESS;
	}

	LSTATUS __stdcall RegCloseKeyHook(HKEY hKey)
	{
		return ERROR_SUCCESS;
	}

	BOOL __stdcall GetVolumeInformationHook(LPCSTR lpRootPathName, LPSTR lpVolumeNameBuffer, DWORD nVolumeNameSize, LPDWORD lpVolumeSerialNumber, LPDWORD lpMaximumComponentLength, LPDWORD lpFileSystemFlags, LPSTR lpFileSystemNameBuffer, DWORD nFileSystemNameSize)
	{
		*lpVolumeSerialNumber = 0x1111;
		return TRUE;
	}

	VOID __declspec(naked) StrPrintHook()
	{
		__asm {
			mov eax, [esp+0x8]

			cmp byte ptr [eax], '%'
			jne lbl_cont
			cmp byte ptr [eax+0x1], 'x'
			jne lbl_cont
			cmp byte ptr [eax+0x2], '\0'
			jne lbl_cont
			
			mov eax, [esp+0x4]
			mov dword ptr [eax], 0x0
			retn

			lbl_cont: jmp sprintf
		}
	}
#pragma endregion

#pragma region Beat check
	VOID __stdcall GetSystemTimeHook(LPSYSTEMTIME lpSystemTime)
	{
		lpSystemTime->wYear = 1999;
		lpSystemTime->wMonth = 8;
	}
#pragma endregion

	BOOL __stdcall FakeEntryPoint(HMODULE hModule, DWORD fdwReason, LPVOID lpReserved)
	{
		return TRUE;
	}

	BOOL PatchImportFunction(HOOKER hooker, const CHAR* function, VOID* addr)
	{
		DWORD address = PatchImportByName(hooker, function, addr, NULL, TRUE);
		if (address)
		{
			BYTE block[6];
			*(WORD*)&block[0] = 0x25FF;
			*(DWORD*)&block[2] = address;

			address = FindBlock(hooker, &block, sizeof(block));
			if (address)
			{
				PatchJump(hooker, address, (DWORD)addr);
				return TRUE;
			}
		}

		return FALSE;
	}

#pragma optimize("s", on)
#define f(a) (a + baseOffset)

	VOID LoadV1(HOOKER hooker, const AddressSpaceV1* hookSpace)
	{
		// Game Speed
		{
			config.speed.hooked = TRUE;
			PatchCall(hooker, hookSpace->speed_anim, hook_004E1FA7, 5);
		}

		// Scroll
		{
			config.scroll.edge.hooked = TRUE;

			if (hookSpace->scroll_nop)
			{
				PatchBlock(hooker, hookSpace->scroll_nop, (VOID*)nop4, sizeof(nop4));
				PatchBlock(hooker, hookSpace->scroll_nop + 33, (VOID*)nop4, sizeof(nop4));
			}

			PatchCall(hooker, hookSpace->scroll_speed, hook_004E0323);
			PatchCall(hooker, hookSpace->scroll_hook, hook_004E0AA8);
			PatchCall(hooker, hookSpace->scroll_hook + 72, hook_004E0AF0);
			PatchCall(hooker, hookSpace->scroll_key_hook, hook_0053D7EE, 3);
		}

		// Random
		if (hookSpace->random_nop)
			PatchNop(hooker, hookSpace->random_nop, 5);

		// No CD
		if (hookSpace->no_cd)
		{
			PatchDWord(hooker, hookSpace->no_cd, 0x9040C031);
			PatchNop(hooker, hookSpace->no_cd + 4, 9);
		}

		// Interlock Fix
		sub_EndLock = (ENDLOCK)RedirectCall(hooker, hookSpace->interlockFix, InterlockHook);

		// Fix negative mouse position
		{
			// Mouse action
			PatchByte(hooker, hookSpace->mouse_pos_fix + 1, 0xBF);
			PatchByte(hooker, hookSpace->mouse_pos_fix + 10 + 1, 0xBF);

			// Mouse move
			PatchByte(hooker, hookSpace->mouse_pos_fix + 77 + 1, 0xBF);
			PatchByte(hooker, hookSpace->mouse_pos_fix + 77 + 10 + 1, 0xBF);
		}

		// HD
		if (config.hd)
		{
			config.resHooked = TRUE;

			Size size;
			if (!config.isExist)
			{
				size.width = (DWORD)GetSystemMetrics(SM_CXSCREEN);
				size.height = (DWORD)GetSystemMetrics(SM_CYSCREEN);

				Config::CalcZoomed(&size, &size, config.zoom.value);

				Config::Set(CONFIG_WRAPPER, "DisplayWidth", *(INT*)&size.width);
				Config::Set(CONFIG_WRAPPER, "DisplayHeight", *(INT*)&size.height);
			}
			else
			{
				size.width = (DWORD)Config::Get(CONFIG_WRAPPER, "DisplayWidth", *(INT*)&GAME_WIDTH);
				size.height = (DWORD)Config::Get(CONFIG_WRAPPER, "DisplayHeight", *(INT*)&GAME_HEIGHT);

				if (size.width < *(DWORD*)&GAME_WIDTH || size.height < *(DWORD*)&GAME_HEIGHT || size.width > 2048 || size.height > 1024)
				{
					size.width = GAME_WIDTH;
					size.height = GAME_HEIGHT;
				}
			}

			config.mode = modesList;

			*(Size*)config.mode = size;
			config.resolution.width = LOWORD(config.mode->width);
			config.resolution.height = LOWORD(config.mode->height);

			if (config.mode->width != GAME_WIDTH || config.mode->height != GAME_HEIGHT)
			{
				Config::CalcZoomed();

				// Borders
				{
					if (hookSpace->dlg_Create && hookSpace->dlg_Delete)
					{
						PatchCall(hooker, hookSpace->dlg_Create, hook_004E746D);
						sub_004E74F1 = RedirectCall(hooker, hookSpace->dlg_Delete, hook_004E74D8);

						config.zoom.allowed = TRUE;
					}

					if (!config.zoom.allowed)
						config.zoom.enabled = FALSE;

					CheckBordersV1();
				}

				{
					PatchImportByName(hooker, "CreateFileA", CreateFileHook);
					PatchImportByName(hooker, "GetFileSize", GetFileSizeHook);
					PatchImportByName(hooker, "ReadFile", ReadFileHook);
					PatchImportByName(hooker, "CloseHandle", CloseHandleHook);
				}

				hud.pitch = config.mode->width + 179;
				if (hud.pitch & 3)
					hud.pitch = (hud.pitch & 0xFFFFFFFC) + 4;
				hud.buffer = (BYTE*)MemoryAlloc(hud.pitch * config.mode->height);

				PatchBlock(hooker, hookSpace->res_mode_1, config.mode, sizeof(DWORD) * 2);
				if (hookSpace->res_mode_2)
					PatchBlock(hooker, hookSpace->res_mode_2, config.mode, sizeof(DWORD) * 2);

				lineList = (DWORD*)MemoryAlloc(config.mode->height * sizeof(DWORD));
				PatchCall(hooker, hookSpace->res_linelist_hook, PopolateList);

				// CreateDialog hook
				if (ReadDWord(hooker, hookSpace->res_CreateDialog + 1, &off_0055106A))
					PatchCall(hooker, hookSpace->res_CreateDialog, hook_0055106A);

				// CreateDialog ISO hook
				if (hookSpace->res_CreateIsoDialog && ReadDWord(hooker, hookSpace->res_CreateIsoDialog + 1, &off_0046541D))
					PatchCall(hooker, hookSpace->res_CreateIsoDialog, hook_0046541D);

				// Load Image V1
				PatchHook(hooker, hookSpace->res_LoadImage, hook_004F0B39);

				// StartDecodeImage
				PatchCall(hooker, hookSpace->res_StartDecodeImage, hook_004F12D6);

				// EndDecodeImage
				PatchHook(hooker, hookSpace->res_EndDecodeImage, hook_004F157A);
			}
		}
	}

	VOID LoadV2(HOOKER hooker, const AddressSpaceV2* hookSpace)
	{
		DWORD baseOffset = GetBaseOffset(hooker);

		// Async spell & death sounds
		if (hookSpace->async_spell)
		{
			sub_PlaySpell = RedirectCall(hooker, hookSpace->async_spell, hook_004F21C0);
			sub_PlayDeath = RedirectCall(hooker, hookSpace->async_death, hook_004EF722);
			sub_PlayRuin = RedirectCall(hooker, hookSpace->async_ruin, hook_004F1D80);
		}

		// Game Speed
		{
			config.speed.hooked = TRUE;
			PatchCall(hooker, hookSpace->speed_anim, hook_00519FF1, 2);
			PatchCall(hooker, hookSpace->speed_map, hook_0051A0A9, 2);

			// Get Time fix
			DWORD addr;
			if (ReadDWord(hooker, hookSpace->speed_anim + 8, &addr))
				PatchHook(hooker, hookSpace->speed_anim + 8 + 4 + addr, GetTimeHook);
		}

		// Scroll
		{
			config.scroll.edge.hooked = TRUE;
			sub_GetCursorPos = RedirectCall(hooker, hookSpace->scroll_check, GetCursorPosHookV2a);

			if (hookSpace->scroll_nop_1)
			{
				PatchBlock(hooker, hookSpace->scroll_nop_1, (VOID*)nop4, sizeof(nop4));
				PatchBlock(hooker, hookSpace->scroll_nop_1 + 33, (VOID*)nop4, sizeof(nop4));
			}

			if (hookSpace->scroll_nop_2)
			{
				PatchBlock(hooker, hookSpace->scroll_nop_2, (VOID*)nop4, sizeof(nop4));
				PatchBlock(hooker, hookSpace->scroll_nop_2 + 33, (VOID*)nop4, sizeof(nop4));
			}

			PatchCall(hooker, hookSpace->scroll_speed, hook_0053D185, 1);
			PatchCall(hooker, hookSpace->scroll_hook, hook_0053D94B);
			PatchCall(hooker, hookSpace->scroll_hook + 65, hook_0053D98C);
			PatchCall(hooker, hookSpace->scroll_key_hook, hook_0053D7EE, 3);

			PatchCall(hooker, hookSpace->dblclick_hook, hook_0053A73D);
		}

		// Cold CPU
		{
			// wait dialog
			if (ReadDWord(hooker, hookSpace->waitClass + 2, &waitAddress))
				PatchHook(hooker, hookSpace->waitHook, hook_004F1464);

			// wait cursor
			sub_0052EE9E = RedirectCall(hooker, hookSpace->waitShowCursor, hook_0053C095);

			if (ReadDWord(hooker, hookSpace->waitLoadCursor + 1, &sub_006ACED2))
			{
				PatchHook(hooker, hookSpace->waitLoadCursor, hook_005AE161);
				sub_005AE161 = f(hookSpace->waitLoadCursor + 5);
				sub_006ACED2 += sub_005AE161;
			}
		}

		// Messages real time
		PatchCall(hooker, hookSpace->msgTimeHook, hook_00484CD0);
		config.msgTimeScale.hooked = TRUE;

		// Print text
		if (hookSpace->print_text)
		{
			sub_PrintText = f(hookSpace->print_text);
			sub_GameObjectInit = RedirectCall(hooker, hookSpace->print_init, hook_00405A1A);
			sub_GameObjectDeInit = RedirectCall(hooker, hookSpace->print_deinit, hook_0048A93C);
		}

		// Png
		{
			pnglib_create_read_struct = (PNG_CREATE_READ_STRUCT)f(hookSpace->png_create_read_struct);
			pnglib_create_info_struct = (PNG_CREATE_INFO_STRUCT)f(hookSpace->png_create_info_struct);
			pnglib_set_read_fn = (PNG_SET_READ_FN)f(hookSpace->png_set_read_fn);
			pnglib_destroy_read_struct = (PNG_DESTROY_READ_STRUCT)f(hookSpace->png_destroy_read_struct);
			pnglib_read_info = (PNG_READ_INFO)f(hookSpace->png_read_info);
			pnglib_read_image = (PNG_READ_IMAGE)f(hookSpace->png_read_image);

			pnglib_create_write_struct = (PNG_CREATE_WRITE_STRUCT)f(hookSpace->png_create_write_struct);
			pnglib_set_write_fn = (PNG_SET_WRITE_FN)f(hookSpace->png_set_write_fn);
			pnglib_destroy_write_struct = (PNG_DESTROY_WRITE_STRUCT)f(hookSpace->png_destroy_write_struct);
			pnglib_write_info = (PNG_WRITE_INFO)f(hookSpace->png_write_info);
			pnglib_write_image = (PNG_WRITE_IMAGE)f(hookSpace->png_write_image);
			pnglib_write_end = (PNG_WRITE_END)f(hookSpace->png_write_end);
			pnglib_set_filter = (PNG_SET_FILTER)f(hookSpace->png_set_filter);
			pnglib_set_IHDR = (PNG_SET_IHDR)f(hookSpace->png_set_IHDR);
		}

		// Map bit-mask fix
		PatchHook(hooker, hookSpace->bitmaskFix, hook_005C848D);

		// Random
		PatchNop(hooker, hookSpace->random_nop, 5);

		// No CD
		if (hookSpace->no_cd)
		{
			PatchDWord(hooker, hookSpace->no_cd, 0x9040C031);
			PatchNop(hooker, hookSpace->no_cd + 4, 6);
		}

		// AI list fix
		if (hookSpace->ai_list_hook_1)
		{
			sub_45287F = RedirectCall(hooker, hookSpace->ai_list_hook_1, sub_45287F_Hook);
			PatchCall(hooker, hookSpace->ai_list_hook_2, sub_45287F_Hook);
			sub_GetType = f(hookSpace->ai_list_get_type);
		}

		// Summoner Fix
		if (hookSpace->summoner_fix)
			sub_005E9984 = RedirectCall(hooker, hookSpace->summoner_fix, hook_0062682E);

		// Interlock Fix
		{
			sub_BeginLock = (BEGINLOCK)f(hookSpace->lock_begin);
			sub_EndLock = (ENDLOCK)f(hookSpace->lock_end);
			sub_BeginLock_2 = (BEGINLOCK)f(hookSpace->lock_begin_2);
			sub_EndLock_2 = (ENDLOCK)f(hookSpace->lock_end_2);

			PatchCall(hooker, hookSpace->interlockFix, InterlockHook);
		}

		// Fix negative mouse position
		{
			// Mouse action
			PatchByte(hooker, hookSpace->mouse_pos_fix + 1, 0xBF);
			PatchByte(hooker, hookSpace->mouse_pos_fix + 10 + 1, 0xBF);

			// Mouse move
			PatchByte(hooker, hookSpace->mouse_pos_fix + 144 + 1, 0xBF);
			PatchByte(hooker, hookSpace->mouse_pos_fix + 144 + 10 + 1, 0xBF);
		}

		// Remove mouse position check outside bounds
		if (hookSpace->mouse_pos_nop_1 && hookSpace->mouse_pos_nop_2)
		{
			PatchJump(hooker, hookSpace->mouse_pos_nop_1, hookSpace->mouse_pos_nop_1 + 45); // Mouse move
			PatchJump(hooker, hookSpace->mouse_pos_nop_2, hookSpace->mouse_pos_nop_2 + 45); // Mouse action
		}

		// Map move by mouse press
		if (ReadDWord(hooker, hookSpace->iso_view_interface, &sub_DeleteIsoView) && ReadDWord(hooker, hookSpace->iso_view_interface + 8, &sub_MouseMove) && ReadDWord(hooker, hookSpace->iso_view_interface + 12, &sub_MouseAction))
		{
			config.scroll.buttons.hooked = TRUE;

			PatchPtr(hooker, hookSpace->iso_view_interface, DeleteIsoView);
			PatchPtr(hooker, hookSpace->iso_view_interface + 8, MouseMove);
			PatchPtr(hooker, hookSpace->iso_view_interface + 12, MouseAction);

			if (hookSpace->iso_view_info_interface && ReadDWord(hooker, hookSpace->iso_view_info_interface, &sub_DeleteIsoInfoView))
			{
				PatchPtr(hooker, hookSpace->iso_view_info_interface, DeleteIsoInfoView);
				PatchPtr(hooker, hookSpace->iso_view_info_interface + 8, MouseMove);
				PatchPtr(hooker, hookSpace->iso_view_info_interface + 12, MouseAction);
			}

			if (hookSpace->iso_view_events_interface && ReadDWord(hooker, hookSpace->iso_view_events_interface, &sub_DeleteIsoEventsView))
			{
				PatchPtr(hooker, hookSpace->iso_view_events_interface, DeleteIsoEventsView);
				PatchPtr(hooker, hookSpace->iso_view_events_interface + 8, MouseMove);
				PatchPtr(hooker, hookSpace->iso_view_events_interface + 12, MouseAction);
			}

			if (hookSpace->iso_view_map_interface && ReadDWord(hooker, hookSpace->iso_view_map_interface, &sub_DeleteIsoMapView) && ReadDWord(hooker, hookSpace->iso_view_map_interface + 12, &sub_MouseActionMap))
			{
				PatchPtr(hooker, hookSpace->iso_view_map_interface, DeleteIsoMapView);
				PatchPtr(hooker, hookSpace->iso_view_map_interface + 8, MouseMove);
				PatchPtr(hooker, hookSpace->iso_view_map_interface + 12, MouseActionMap);
			}

			if (hookSpace->radio_objects_interface && ReadDWord(hooker, hookSpace->radio_objects_interface, &sub_DeleteRadioObjects))
			{
				PatchPtr(hooker, hookSpace->radio_objects_interface, DeleteRadioObjects);
				sub_CreateRadio = RedirectCall(hooker, hookSpace->radio_objects_create, CreateRadioObjects);
			}

			PatchDWord(hooker, hookSpace->mouse_mid_button + 1, WM_MBUTTONUP);

			mouseAction.allow = (BYTE*)f(hookSpace->mouse_allow_flag);
			sub_GetMapCenter = f(hookSpace->map_center_get);
			sub_SetMapCenter = f(hookSpace->map_center_set);
		}

		// AI turn
		if (hookSpace->startAiTurn && hookSpace->endAiTurn)
		{
			sub_GetQueueCommands = RedirectCall(hooker, hookSpace->startAiTurn, StartAiTurnHook);
			PatchCall(hooker, hookSpace->endAiTurn, EndAiTurnHook);
		}

		// Custom Package
		if (hookSpace->pkg_size)
		{
			PatchByte(hooker, hookSpace->pkg_size + 1, 105);
			sub_LoadImgPackage = RedirectCall(hooker, hookSpace->pkg_load, LoadImgPackage);

			PatchHook(hooker, hookSpace->pkg_entry_load, LoadPackageIndex);
			sub_0052A14E = f(hookSpace->pkg_entry_sub);

			// Show clouds
			if (hookSpace->clouds_hook)
			{
				sub_0051F87C = RedirectCall(hooker, hookSpace->clouds_hook, hook_005C2789);
				PatchCall(hooker, hookSpace->clouds_init, hook_005B8F00, 1);
				PatchHook(hooker, hookSpace->clouds_init + 83, hook_005B8F53);
				PatchHook(hooker, hookSpace->clouds_check, hook_005B91BB);
				back_005B9214 = f(hookSpace->clouds_check + 89);
			}
		}

		// Mirror battle bg
		if (hookSpace->pkg_sub)
		{
			sub_005A9A1E = f(hookSpace->pkg_sub);
			PatchCall(hooker, hookSpace->btlLoadBack_1, GetBattleBgFirts);
			PatchCall(hooker, hookSpace->btlLoadBack_2, GetBattleBgNext);
			PatchCall(hooker, hookSpace->btlLoadBack_3, GetBattleBgNext);
		}

		// Sphere fix
		if (hookSpace->sphere_x && hookSpace->sphere_y)
		{
			PatchCall(hooker, hookSpace->sphere_x, hook_00650628);
			PatchCall(hooker, hookSpace->sphere_y, hook_00650674);
		}

		// Resources toogle
		if (hookSpace->resources_set)
		{
			PatchByte(hooker, hookSpace->resources_set, config.toogle.resources);
			flagResPopup = (BYTE*)f(hookSpace->resources_set);

			PatchByte(hooker, hookSpace->resources_nop, 0xC3);
			PatchCall(hooker, hookSpace->resources_hook, hook_004869CB);
		}

		// Banners toogle
		if (hookSpace->banners_set)
		{
			PatchByte(hooker, hookSpace->banners_set, config.toogle.banners);
			PatchByte(hooker, hookSpace->banners_nop, 0xEB);
			if (hookSpace->banners_hook)
				PatchHook(hooker, hookSpace->banners_hook, hook_005AED25);
		}

		// Editor owner trigger
		if (hookSpace->banners_owner_trigger && ReadDWord(hooker, hookSpace->banners_owner_trigger + 3, &sub_SpinOwnerCallback))
			PatchPtr(hooker, hookSpace->banners_owner_trigger + 3, hook_SpinOwnerCallback);

		// Editor check alpanum for map name
		{
			if (hookSpace->locale_fix_1)
			{
				PatchHook(hooker, hookSpace->locale_fix_1, hook_0048FADD);
				back_0048FAFB = f(hookSpace->locale_fix_1 + 30);
			}

			if (hookSpace->locale_fix_2)
			{
				PatchHook(hooker, hookSpace->locale_fix_2, hook_00494AED);
				back_00494B09 = f(hookSpace->locale_fix_2 + 28);
			}
		}

		// Scenarous list
		{
			config.scene.sort.hooked = TRUE;

			if (config.type.editor)
				PatchPtr(hooker, hookSpace->scene_sort_hook + 3, CompareScenes); // Sort by title
			else
				sub_GetScenariosSortedList = RedirectCall(hooker, hookSpace->scene_sort_hook, GetScenariosSortedList);

			sub_CopyStrObject = RedirectCall(hooker, hookSpace->scene_print_edit_hook, AddScenarioSize);

			if (!config.type.editor)
				PatchByte(hooker, hookSpace->scene_print_edit_hook + 13, 0xEB); // remove (Custom) check
			else
				PatchCall(hooker, hookSpace->scene_print_delete_hook, AddScenarioSize);

			CopyString = (COPYSTRING)f(hookSpace->str_copy);
			PrintString = (PRINTSTRING)f(hookSpace->str_print);
		}

		if (config.hd)
		{
			config.bpp32Hooked = TRUE;
			config.background.allowed = config.type.editor;
			SeedRandom(timeGetTime());
			config.randPos.x = Random();
			config.randPos.y = Random();

			PatchImportByName(hooker, "_BinkCopyToBuffer@28", BinkCopyToBufferHook, &pBinkCopyToBuffer);
			Convert565toRGB = config.renderer == RendererGDI ? ConvertToBGR : ConvertToRGB;

			PatchBlock(hooker, hookSpace->pixel, pixelFunctions, sizeof(pixelFunctions));

			// =================================================================

			PatchHook(hooker, hookSpace->fillColor, FillColor); // Fill color
			PatchCall(hooker, hookSpace->minimapGround, DrawMinimapGround); // Minimap ground
			PatchHook(hooker, hookSpace->minimapObjects, DrawMinimapObjects); // Draw minimap object
			PatchPtr(hooker, hookSpace->clearGround, ClearGround); // Clear ground
			PatchHook(hooker, hookSpace->mapGround, DrawGround); // Draw map ground
			PatchHook(hooker, hookSpace->waterBorders, DrawWaterBorders); // Draw water borders

			PatchHook(hooker, hookSpace->symbol, DrawSymbol); // Draw Symbol
			PatchCall(hooker, hookSpace->faces, DrawFaces);
			PatchPtr(hooker, hookSpace->buildings, DrawCastleBuildings);

			PatchHook(hooker, hookSpace->horLine, DrawLineHorizontal); // Draw Horizontal Line
			PatchHook(hooker, hookSpace->verLine, DrawLineVertical); // Draw Vertical Line

			// =================================================================

			PatchCall(hooker, hookSpace->line_1, DrawLine);
			PatchCall(hooker, hookSpace->line_2, DrawLine);

			PatchHook(hooker, hookSpace->unknown_1, hook_005383A5);
			back_005383AA = f(hookSpace->unknown_1 + 5);

			PatchHook(hooker, hookSpace->unknown_2, hook_005383F7);
			back_00538413 = f(hookSpace->unknown_2 + 28);

			// Increase memory
			{
				PatchByte(hooker, hookSpace->memory_1 + 2, 0xC);

				PatchCall(hooker, hookSpace->memory_2, hook_005A6311);

				PatchHook(hooker, hookSpace->memory_3, hook_005BACE1);
				back_005BACE7 = f(hookSpace->memory_3 + 6);

				PatchCall(hooker, hookSpace->memory_4, hook_00674400);
				PatchCall(hooker, hookSpace->memory_5, hook_00674400);
				PatchCall(hooker, hookSpace->memory_6, hook_005A6209);
			}

			if (hookSpace->res_hook)
			{
				config.resHooked = TRUE;

				Size size;
				if (!config.isExist)
				{
					size.width = (DWORD)GetSystemMetrics(SM_CXSCREEN);
					size.height = (DWORD)GetSystemMetrics(SM_CYSCREEN);

					Config::CalcZoomed(&size, &size, config.zoom.value);

					Config::Set(CONFIG_WRAPPER, "DisplayWidth", *(INT*)&size.width);
					Config::Set(CONFIG_WRAPPER, "DisplayHeight", *(INT*)&size.height);
				}
				else
				{
					size.width = (DWORD)Config::Get(CONFIG_WRAPPER, "DisplayWidth", GAME_WIDTH);
					size.height = (DWORD)Config::Get(CONFIG_WRAPPER, "DisplayHeight", GAME_HEIGHT);

					if (size.width < *(DWORD*)&GAME_WIDTH || size.height < *(DWORD*)&GAME_HEIGHT)
					{
						size.width = *(DWORD*)&GAME_WIDTH;
						size.height = *(DWORD*)&GAME_HEIGHT;
					}
				}

				config.mode = &modesList[1];

				*(Size*)config.mode = size;
				config.resolution.width = LOWORD(config.mode->width);
				config.resolution.height = LOWORD(config.mode->height);

				Config::CalcZoomed();
				Config::CalcScroll();

				// Resolution
				{
					PatchHook(hooker, hookSpace->res_hook, hook_00611C8B);
					back_00611CEF = f(hookSpace->res_back);
				}

				// Borders
				{
					if (hookSpace->border_nop)
					{
						PatchNop(hooker, hookSpace->border_nop, 2);
						PatchByte(hooker, hookSpace->border_nop + 0x16, 0xEB); // remove internal borders

						if (config.mode->width > *(DWORD*)&GAME_WIDTH || config.mode->height > *(DWORD*)&GAME_HEIGHT)
						{
							config.borders.allowed = TRUE;
							config.background.allowed = TRUE;
							config.zoom.allowed = TRUE;
						}
					}
					else
						config.background.allowed = TRUE;

					if (!config.borders.allowed)
						config.borders.type = BordersNone;

					if (!config.background.allowed)
						config.background.enabled = FALSE;

					if (!config.zoom.allowed)
						config.zoom.enabled = FALSE;

					if (!hookSpace->border_nop || config.mode->width > *(DWORD*)&GAME_WIDTH || config.mode->height > *(DWORD*)&GAME_HEIGHT)
						PatchCall(hooker, hookSpace->border_hook - 3, hook_00538FEB); // detect border
				}

				// Blit count
				{
					BYTE value;
					ReadByte(hooker, hookSpace->blit_size + 2, &value);

					DWORD count = DWORD((2048.0f * config.mode->width * config.mode->height) / (GAME_WIDTH_FLOAT * GAME_HEIGHT_FLOAT));
					PatchDWord(hooker, hookSpace->blit_patch_1 + 1, count * value);
					PatchDWord(hooker, hookSpace->blit_patch_1 + 0xC + 3, count);

					PatchDWord(hooker, hookSpace->blit_patch_2 + 1, count * 20);
					PatchDWord(hooker, hookSpace->blit_patch_2 + 0x17 + 6, count);
				}

				// Minimap rectangle
				{
					PatchByte(hooker, hookSpace->mini_rect_jmp, 0xEB);
					PatchByte(hooker, hookSpace->mini_rect_jmp + 23, 0xEB);

					FLOAT w = FLOAT(27 - 7) / (GAME_WIDTH - PANEL_WIDTH) * (config.mode->width - PANEL_WIDTH);
					FLOAT h = FLOAT(27 + 7) / GAME_HEIGHT * config.mode->height;

					FLOAT ky = (h - w) * 0.5f;

					LONG x = (LONG)MathRound(w + ky);
					LONG y = (LONG)MathRound(ky);

					PatchLong(hooker, hookSpace->mini_rect_patch + 3, x);
					PatchLong(hooker, hookSpace->mini_rect_patch + 8 + 3, y);
				}

				// Fix right side curve
				if (hookSpace->right_curve)
				{
					PatchHook(hooker, hookSpace->right_curve, hook_00489124);
					back_00489136 = f(hookSpace->right_curve + 18);
				}

				// Fix minimap fill color alpha
				if (hookSpace->minimap_fill)
					PatchNop(hooker, hookSpace->minimap_fill, 6);

				if (config.mode->width > 1152)
				{
					PatchPtr(hooker, hookSpace->maxSize_1 + 2, &config.mode->width);
					PatchPtr(hooker, hookSpace->maxSize_2 + 2, &config.mode->width);
					PatchPtr(hooker, hookSpace->maxSize_3 + 6 + 2, &config.mode->width);
				}

				if (config.mode->height > 1152)
				{
					PatchPtr(hooker, hookSpace->maxSize_1 + 29 + 2, &config.mode->height);
					PatchPtr(hooker, hookSpace->maxSize_2 + 28 + 2, &config.mode->height);
					PatchPtr(hooker, hookSpace->maxSize_3 + 2, &config.mode->height);
				}

				// Centre battle background
				PatchNop(hooker, hookSpace->btlCentrBack, 2);
				PatchCall(hooker, hookSpace->btlCentrBack + 27, hook_0063E6B8);

				// Widescreen Battle
				if (hookSpace->btlClass && config.mode->width >= WIDE_WIDTH && ReadDWord(hooker, hookSpace->btlClass + 2, &battleAddress))
				{
					config.wide.hooked = TRUE;

					if (!config.isExist)
					{
						config.wide.allowed = TRUE;
						Config::Set(CONFIG_WRAPPER, "WideBattle", config.wide.allowed);
					}

					PatchHook(hooker, hookSpace->btlCentrUnits, hook_00625683); // centre battle units
					back_00625688 = f(hookSpace->btlCentrUnits + 5);

					// remove mouse check left group
					sub_00629FAA = RedirectCall(hooker, hookSpace->btlMouseCheck, hook_0062891A);

					// swap groups
					PatchHook(hooker, hookSpace->btlSwapGroup, hook_0062F524);
					back_0062F52A = f(hookSpace->btlSwapGroup + 6);

					// remove set inactive group
					sub_00643E80 = RedirectCall(hooker, hookSpace->btlGroupsInactive, hook_0062F5B8);

					// groups init parameters
					if (hookSpace->version.high == 2)
					{
						PatchCall(hooker, hookSpace->btlGroupsActive, hook_0062521D); // set groups active

						// Reverse groups back
						PatchCall(hooker, hookSpace->btlReverseGroup, hook_00624F2F, 1);
						PatchCall(hooker, hookSpace->btlInitGroups1_1, hook_00625EAE, 3);
						PatchCall(hooker, hookSpace->btlInitGroups1_2, hook_00625EFD, 1);
						PatchCall(hooker, hookSpace->btlInitGroups1_3, hook_00625EFD, 1);
						PatchCall(hooker, hookSpace->btlInitGroups2_1, hook_0062635D, 3);
						PatchCall(hooker, hookSpace->btlInitGroups2_2, hook_006263AC, 1);
						PatchCall(hooker, hookSpace->btlInitGroups2_3, hook_006263AC, 1);
					}
					else if (hookSpace->version.high == 3)
					{
						PatchCall(hooker, hookSpace->btlGroupsActive, hook_0062DAA8); // set groups active

						// Reverse groups back
						PatchCall(hooker, hookSpace->btlReverseGroup, hook_0062ED48, 1);
						//PatchCall(hooker, hookSpace->btlInitGroups1_1, hook_0062E7FB, 1);
						PatchCall(hooker, hookSpace->btlInitGroups1_2, hook_0062E848, 1);
						PatchCall(hooker, hookSpace->btlInitGroups1_3, hook_0062E848, 1);
						//PatchCall(hooker, hookSpace->btlInitGroups2_1, hook_0062ECA9, 1);
						PatchCall(hooker, hookSpace->btlInitGroups2_2, hook_0062ECFC, 1);
						PatchCall(hooker, hookSpace->btlInitGroups2_3, hook_0062ECFC, 1);
					}

					// change image indices
					sub_00625387 = RedirectCall(hooker, hookSpace->btlImgIndices, hook_00625387);

					// fix items use for left side
					PatchCall(hooker, hookSpace->btnItemsUseFix, hook_006307E8, 2);
					rectListShift = hookSpace->version.high == 3 ? 0x1260 : 0x8C0;

					// set dialog
					PatchCall(hooker, hookSpace->btlDialog_1, hook_006244CA, 1);
					PatchCall(hooker, hookSpace->btlDialog_2, hook_0062476C, 1);

					if (hookSpace->btlFileGetStr)
						sub_fgets = RedirectCall(hooker, hookSpace->btlFileGetStr, SteamFileGetStrHook);
					else
						PatchImportByName(hooker, "fgets", FileGetStrHook);
				}

				// Debug & message position
				{
					// Calc debug window
					PatchCall(hooker, hookSpace->debugPosition, hook_0052EAAE, 1);

					// Calc messages
					PatchCall(hooker, hookSpace->msgIconPosition, hook_00484DD1);
					PatchCall(hooker, hookSpace->msgTextPosition, hook_00484DD1);
				}
			}
		}
	}

	VOID Load()
	{
		{
			CHAR path[MAX_PATH];
			GetModuleFileName(NULL, path, MAX_PATH - 1);
			CHAR* p = StrLastChar(path, '\\');
			StrCopy(p, "\\DDRAW.dll");
			HMODULE hLib = GetModuleHandle(path);
			if (hLib)
			{
				HOOKER hooker = CreateHooker(hLib);
				{
					PatchEntry(hooker, FakeEntryPoint);
				}
				ReleaseHooker(hooker);
			}
		}

		HOOKER user = CreateHooker(GetModuleHandle("USER32.dll"));
		{
			PatchExport(user, "MessageBoxA", MessageBoxHook);
			PatchExport(user, "DialogBoxParamA", DialogBoxParamHook);
		}
		ReleaseHooker(user);

		HOOKER hooker = CreateHooker(GetModuleHandle(NULL));
		{
			{
				PatchImportByName(hooker, "GetDeviceCaps", GetDeviceCapsHook);
				PatchImportByName(hooker, "GetForegroundWindow", GetForegroundWindowHook);

				PatchImportByName(hooker, "CreateWindowExA", CreateWindowExHook);
				PatchImportByName(hooker, "RegisterClassA", RegisterClassHook);

				PatchImportByName(hooker, "SetWindowLongA", SetWindowLongHook);

				PatchImportByName(hooker, "MessageBoxA", MessageBoxHook);

				if (!PatchImportByName(hooker, "RegisterWindowMessageA", RegisterWindowMessageHook))
					PatchImportByName(hooker, "RegisterClipboardFormatA", RegisterWindowMessageHook); // for cracks

				PatchImportByName(hooker, "SetThreadPriority", SetThreadPriorityHook);

				PatchImportByName(hooker, "ShowCursor", ShowCursorHook);
				PatchImportByName(hooker, "ClipCursor", ClipCursorHook);

				PatchImportByName(hooker, "GetClientRect", GetClientRectHook);
				PatchImportByName(hooker, "GetWindowRect", GetWindowRectHook);

				PatchImportByName(hooker, "GetOpenFileNameA", GetOpenFileNameHook);
				PatchImportByName(hooker, "GetSaveFileNameA", GetSaveFileNameHook);

				PatchImportByName(hooker, "isalpha", IsAlphaHook);
				PatchImportByName(hooker, "isalnum", IsAlNumHook);
				PatchImportByName(hooker, "isdigit", IsDigitHook);
				PatchImportByName(hooker, "isspace", IsSpaceHook);
				PatchImportByName(hooker, "ispunct", IsPunctHook);
				PatchImportByName(hooker, "iscntrl", IsCntrlHook);
				PatchImportByName(hooker, "isupper", IsUpperHook);
				PatchImportByName(hooker, "toupper", ToUpperHook);
				PatchImportByName(hooker, "tolower", ToLowerHook);
				PatchImportByName(hooker, "strchr", StrCharHook);
				PatchImportByName(hooker, "memchr", MemoryCharHook);

				if (config.locales.current.oem && config.locales.current.ansi)
				{
					PatchImportByName(hooker, "OemToCharA", OemToCharHook);
					PatchImportByName(hooker, "CharToOemA", CharToOemHook);
				}
			}

			if (config.type.sacred)
			{
				PatchImportByName(hooker, "PeekMessageA", PeekMessageHook);
				PatchImportByName(hooker, "GetCursorPos", GetCursorPosHookV1);
				PatchImportByName(hooker, "ClientToScreen", ClientToScreenHook);
				PatchImportByName(hooker, "GetDoubleClickTime", GetDoubleClickTimeHook);
				PatchImportByName(hooker, "CoCreateInstance", CoCreateInstanceHook);
				PatchImportByName(hooker, "GetSystemTime", GetSystemTimeHook);

				const AddressSpaceV1* hookSpace = addressArrayV1;
				DWORD hookCount = sizeof(addressArrayV1) / sizeof(AddressSpaceV1);
				do
				{
					DWORD check;
					if (ReadDWord(hooker, hookSpace->check + 1, &check) && check == WS_POPUP && hookSpace->version_major.value == config.version.major.value && hookSpace->version_minor.value == config.version.minor.value)
					{
						LoadV1(hooker, hookSpace);
						break;
					}

					++hookSpace;
				} while (--hookCount);
			}
			else
			{
				PatchImportFunction(hooker, "DirectDrawEnumerateExA", Main::DrawEnumerateEx);
				PatchImportFunction(hooker, "DirectDrawCreate", Main::DrawCreate);
				PatchImportFunction(hooker, "DirectDrawCreateEx", Main::DrawCreateEx);

				PatchImportByName(hooker, "GetCursorPos", GetCursorPosHookV2);
				PatchImportByName(hooker, "SetCursorPos", SetCursorPosHook);
				PatchImportByName(hooker, "GetAsyncKeyState", GetKeyState);
				PatchImportByName(hooker, "GetSystemMetrics", GetSystemMetricsHook);

				PatchImportByName(hooker, "GetPrivateProfileStringA", GetPrivateProfileStringHook);

				if (PatchImportByName(hooker, "RegOpenKeyExA", RegOpenKeyExHook))
				{
					PatchImportByName(hooker, "RegQueryValueExA", RegQueryValueExHook);
					PatchImportByName(hooker, "RegCloseKeyHook", RegCloseKeyHook);
					PatchImportByName(hooker, "GetVolumeInformationA", GetVolumeInformationHook);
					PatchImportByName(hooker, "sprintf", StrPrintHook);
				}

				const AddressSpaceV2* hookSpace = addressArrayV2;
				DWORD hookCount = sizeof(addressArrayV2) / sizeof(AddressSpaceV2);
				do
				{
					DWORD check;
					if (ReadDWord(hooker, hookSpace->check + 1, &check) && check == (WS_CAPTION | WS_SYSMENU | WS_MINIMIZEBOX) && hookSpace->version_major.value == config.version.major.value && hookSpace->version_minor.value == config.version.minor.value)
					{
						LoadV2(hooker, hookSpace);
						break;
					}

					++hookSpace;
				} while (--hookCount);
			}

			if (!config.speed.hooked)
				PatchImportByName(hooker, "timeGetTime", timeGetTimeHook);
		}
		ReleaseHooker(hooker);
	}
#pragma optimize("", on)
}